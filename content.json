{"meta":{"title":"李云鹏的个人博客","subtitle":null,"description":"萍水相逢也是前世之缘","author":"李云鹏","url":"http://gaianote.github.io"},"pages":[],"posts":[{"title":"python多进程","slug":"python多进程","date":"2017-05-20T16:03:44.000Z","updated":"2017-05-21T12:01:28.902Z","comments":true,"path":"2017/05/21/python多进程/","link":"","permalink":"http://gaianote.github.io/2017/05/21/python多进程/","excerpt":"","text":"基本使用在 multiprocessing 中，每一个进程都用一个 Process 类来表示。首先看下它的API 1Process([group [, target [, name [, args [, kwargs]]]]]) target 表示调用对象，你可以传入方法的名字 args 表示被调用对象的位置参数元组，比如target是函数a，他有两个参数m，n，那么args就传入(m, n)即可 kwargs 表示调用对象的字典 name 是别名，相当于给这个进程取一个名字 group 分组，实际上不使用 我们先用一个实例来感受一下： 123456789import multiprocessingdef process(num): print ('Process:', num)if __name__ == '__main__': for i in range(5): p = multiprocessing.Process(target=process, args=(i,)) p.start() 最简单的创建Process的过程如上所示，target传入函数名，args是函数的参数，是元组的形式，如果只有一个参数，那就是长度为1的元组。 然后调用start()方法即可启动多个进程了。 另外你还可以通过 cpu_count() 方法还有 active_children() 方法获取当前机器的 CPU 核心数量以及得到目前所有的运行的进程。 1234567891011121314151617import multiprocessingimport timedef process(num): time.sleep(num) print ('Process:', num)if __name__ == '__main__': for i in range(5): p = multiprocessing.Process(target=process, args=(i,)) p.start() print('CPU number:' + str(multiprocessing.cpu_count())) for p in multiprocessing.active_children(): print('Child process name: ' + p.name + ' id: ' + str(p.pid)) print('Process Ended') Lock并行输出结果会导致错位，我们可以通过Lock进行加锁 12345678910111213141516171819202122from multiprocessing import Process, Lockimport timeclass MyProcess(Process): def __init__(self, loop, lock): Process.__init__(self) self.loop = loop self.lock = lock def run(self): for count in range(self.loop): time.sleep(0.1) self.lock.acquire() print('Pid: ' + str(self.pid) + ' LoopCount: ' + str(count)) self.lock.release()if __name__ == '__main__': lock = Lock() for i in range(10, 15): p = MyProcess(i, lock) p.start() Python Queue模块详解Python Queue模块详解","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"","slug":"nodejs6下使用koa2框架","date":"2017-05-20T06:16:24.093Z","updated":"2017-05-20T06:31:32.658Z","comments":true,"path":"2017/05/20/nodejs6下使用koa2框架/","link":"","permalink":"http://gaianote.github.io/2017/05/20/nodejs6下使用koa2框架/","excerpt":"","text":"koa2里面使用ES7的语法，如async、await所以需要运行在node7.6之后；但在node7.6之前也可以利用babel是的koa2可以运行。 首先项目中安装babel，和babel的几个模块： 1npm install babel babel-register babel-preset-env --save 然后在入口文件中引入‘babel-register’模块 1require('babel-register'); 而后引入业务代码： 1require('./server.js'); 在配置.babelrc文件： 123456789&#123; \"presets\": [ [\"env\", &#123; \"targets\": &#123; \"node\": true &#125; &#125;] ]&#125; app.js: 123require('babel-register');require('./servers/devserver'); devserver.js: 12345678var koa = require('koa');var app = new koa();app.use(async (ctx) =&gt; &#123; await ctx.body = 'hello world!'&#125;);app.listen(8080); 源码地址","categories":[],"tags":[]},{"title":"sublime","slug":"sublime","date":"2017-05-17T16:03:44.000Z","updated":"2017-05-18T08:38:20.759Z","comments":true,"path":"2017/05/18/sublime/","link":"","permalink":"http://gaianote.github.io/2017/05/18/sublime/","excerpt":"","text":"快捷键Ctrl+P ：Goto AnythingCtrl+P : 查找项目中的文件： 直接输入名称：在不同文件中切换，支持级联的目录模式 :：+ 行号：Ctrl+G 定位到具体的行。@：+ 符号：Ctrl+R 定位到具体的符号，例如：JS函数名，CSS选择器名。#：+ 关键字：Ctrl+; 匹配到具体的匹配的关键字。主要是模糊匹配。 sublime配置文件个人正在使用的sublime配置文件，解决了文件名中文显示为□□□等问题 12345678910111213141516171819202122&#123; \"bold_folder_labels\": true, \"dpi_scale\": 1.0, \"font_face\": \"Consolas\", \"font_size\": 16, \"highlight_line\": true, \"highlight_modified_tabs\": true, \"ignored_packages\": [ \"Vintage\" ], \"line_padding_bottom\": 1, \"line_padding_top\": 1, \"save_on_focus_lost\": true, \"show_encoding\": true, \"tab_size\": 2, \"translate_tabs_to_spaces\": true, \"trim_trailing_white_space_on_save\": true, \"word_wrap\": false, \"hot_exit\": false, \"remember_open_files\": false&#125; 常用功能插件安装安装插件管理包 Package Control 打开Package Control的官方网页,点击右侧的 Install Now 按钮 复制对应版本 2.0或 3.0的代码段 Ctrl + ~ 打开Sublime Text控制台，将之前复制的代码粘贴到控制台里，按下“Enter”键 重启程序,点开菜单 Preferences 可见 Package Control 项，说明插件管理包已安装成功。 安装的两种方式以 ConvertToUTF8 插件安装为例： 功能说明 对于一些编码格式会导致中文乱码,ConcertToUTF8专为解决该问题而编写 ConvertToUTF8 能将除UTF8编码之外的其他编码文件在 Sublime Text 中转换成UTF8编码 在保存文件之后原文件的编码格式不会改变 安装方法 通过 Package Control 在线安装 菜单 Preferences -&gt; Package Control -&gt; :Install Package 由于网络等问题,可能会等待数秒或更长时间才会响应,待出现插件搜索框后,输入需要的插件名称 插件会自动安装,安装过程无任何提示,由于网络等问题,可能会等待数秒或更长时间 安装成功后,会弹出Package Control Messages页面,而packag setting中也会出现该插件名称 通过文件夹的方式本地安装 菜单 Preferences -&gt; Brower Package 打开Package本地文件 将解压好的插件包复制到这个 Packages 目录下 markdown解决方案markdown语法高亮 首先安装 Markdown Extended + Monokai Extended 这两个主题 选择 Preference &gt; Color Scheme &gt; Monokai Extended 更换主题颜色为 Monokai Extended 打开一个 markdown 文件，选择 View &gt; Syntax &gt; open all with current ... &gt; Markdown Extended 设置 markdown 语法规则为 Markdown Extended 个人插件和使用方法AdvancedNewFile : 快速新建文件。假设有文件夹file。我们正在输入代码，又想在新的子目录下新建html文件的话用传统方式得很多步，新建目录，新建文件，保存等等等。 但是有了该插件之后，事情就变得简单了许多，只需要按下 Ctrl+ALT+N ，输入文件夹以及文件名，你就会看到如下效果:（回车，你会发现已经子目录下的文件已经新建完成了！） Terminal ：在Sublime Text直接打开命令行默认快捷键 Ctrl+Shift+T。 在windows下默认会打开Windows PowerShell，那界面简直丑到不行好吗！！ 根据上面的经验同样找到preference–&gt;package Settings–&gt;Terminal–&gt;Terminal Settings-users：进行下面的设置： 1234&#123; \"terminal\": \"F:\\\\Program Files\\\\cmder\\\\Cmder.exe\", \"parameters\": [\"/START\", \"%CWD%\"]&#125; 在sublime下运行python程序sublime 自带运行 python 程序功能，使用快捷键 ctrl + B 即可。 更美观的界面或者进入命令行交互模式还需要插件的支持，这里推荐 sublimeREPL 插件 在你写好的python文件的界面里(这点需要注意)，点击上方菜单栏的tools-&gt;sublimeREPL-&gt;python-&gt;python run current file，即可交互输入 使用快捷键运行程序 在 preferences–&gt; key binding–&gt; user 中输入以下内容: 123456789101112&#123; \"keys\": [\"f5\"], \"caption\": \"Python - RUN current file\", \"command\": \"repl_open\", \"args\": &#123; \"type\": \"subprocess\", \"encoding\": \"utf8\", \"cmd\": [\"python\", \"-u\", \"$file_basename\"], \"cwd\": \"$file_path\", \"syntax\": \"Packages/Python/Python.tmLanguage\", \"external_id\": \"python\", \"extend_env\": &#123;\"PYTHONIOENCODING\": \"utf-8\"&#125; &#125;&#125;","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://gaianote.github.io/tags/tool/"}]},{"title":"在bae搭建flask服务器","slug":"在bae搭建flask服务器","date":"2017-05-11T15:38:25.000Z","updated":"2017-05-16T02:52:15.494Z","comments":true,"path":"2017/05/11/在bae搭建flask服务器/","link":"","permalink":"http://gaianote.github.io/2017/05/11/在bae搭建flask服务器/","excerpt":"","text":"使用百度bae搭建flask服务器，有以下几点需要注意: 目录结构 12345app|-app.conf|-favicon.io|-index.py|-requirement.txt 在 requirement.txt 写入需要依赖的包，若没有 requirement.txt 文件则新建即可 1flask 在 app.conf 更改路由规则，若不更改则 flask 路由无法访问，会返回 404 默认的配置只能作用于 / 123handlers: - url : / script: index.py 更改为： 123handlers: - url : /.* script: index.py","categories":[],"tags":[]},{"title":"python获取本机IP、mac地址、计算机名","slug":"python获取本机IP、mac地址、计算机名","date":"2017-05-11T06:36:20.000Z","updated":"2017-05-16T02:52:15.412Z","comments":true,"path":"2017/05/11/python获取本机IP、mac地址、计算机名/","link":"","permalink":"http://gaianote.github.io/2017/05/11/python获取本机IP、mac地址、计算机名/","excerpt":"","text":"在Python中获取ip地址和在PHP中有很大不同，在php中往往比较简单。那再python中怎么做呢？我们先来看一下python 获得本机MAC地址： 1234import uuiddef get_mac_address(): mac=uuid.UUID(int = uuid.getnode()).hex[-12:] return \":\".join([mac[e:e+2] for e in range(0,11,2)]) 下面再来看一下python获取IP的方法：使用socket 1234567import socket#获取本机电脑名myname = socket.getfqdn(socket.gethostname( ))#获取本机ipmyaddr = socket.gethostbyname(myname)print mynameprint myaddr 在linux下可用1234567891011121314151617181920import socketimport fcntlimport structdef get_ip_address(ifname): s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) return socket.inet_ntoa(fcntl.ioctl( s.fileno(), 0x8915, # SIOCGIFADDR struct.pack('256s', ifname[:15]) )[20:24])get_ip_address('lo')# '127.0.0.1'get_ip_address('eth0')# '38.113.228.130'get_ip_address('ppp0')# '123.163.166.00'","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"centos6/7安装tinyproxy","slug":"centos6-7安装tinyproxy","date":"2017-05-09T09:44:14.000Z","updated":"2017-05-16T02:52:15.254Z","comments":true,"path":"2017/05/09/centos6-7安装tinyproxy/","link":"","permalink":"http://gaianote.github.io/2017/05/09/centos6-7安装tinyproxy/","excerpt":"","text":"安装tinyproxy123yum install -y epel-releaseyum updateyum -y install tinyproxy 配置tinyproxy修改Allow 127.0.0.1为自己IP，只允许自己使用，或者在Allow前面打#注释，允许任何IP都可以连接 1vi /etc/tinyproxy/tinyproxy.conf 启动Tinyproxy服务，并设置开机自启12345service tinyproxy restartchkconfig --level 345 tinyproxy on#centos7如下设置:systemctl restart tinyproxy.servicesystemctl enable tinyproxy.service 防火墙开放8888（或已经自定义）端口1234iptables -I INPUT -p tcp --dport 8888 -j ACCEPT#centos7如下设置:firewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --reload","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://gaianote.github.io/tags/linux/"}]},{"title":"linux下vi命令速查手册","slug":"linux下vi命令速查手册","date":"2017-05-09T05:05:16.000Z","updated":"2017-05-16T02:52:15.334Z","comments":true,"path":"2017/05/09/linux下vi命令速查手册/","link":"","permalink":"http://gaianote.github.io/2017/05/09/linux下vi命令速查手册/","excerpt":"","text":"进入vi的命令vi filename :打开或新建文件，并将光标置于第一行首vi +n filename ：打开文件，并将光标置于第n行首vi + filename ：打开文件，并将光标置于最后一行首vi +/pattern filename：打开文件，并将光标置于第一个与pattern匹配的串处vi -r filename ：在上次正用vi编辑时发生系统崩溃，恢复filenamevi filename….filename ：打开多个文件，依次进行编辑 移动光标类命令h ：光标左移一个字符l ：光标右移一个字符space：光标右移一个字符Backspace：光标左移一个字符k或Ctrl+p：光标上移一行j或Ctrl+n ：光标下移一行Enter ：光标下移一行w或W ：光标右移一个字至字首b或B ：光标左移一个字至字首e或E ：光标右移一个字至字尾) ：光标移至句尾( ：光标移至句首}：光标移至段落开头{：光标移至段落结尾nG：光标移至第n行首n+：光标下移n行n-：光标上移n行n$：光标移至第n行尾H ：光标移至屏幕顶行M ：光标移至屏幕中间行L ：光标移至屏幕最后行0：（注意是数字零）光标移至当前行首$：光标移至当前行尾 屏幕翻滚类命令Ctrl+u：向文件首翻半屏Ctrl+d：向文件尾翻半屏Ctrl+f：向文件尾翻一屏Ctrl＋b；向文件首翻一屏nz：将第n行滚至屏幕顶部，不指定n时将当前行滚至屏幕顶部。 插入文本类命令i ：在光标前I ：在当前行首a：光标后A：在当前行尾o：在当前行之下新开一行O：在当前行之上新开一行r：替换当前字符R：替换当前字符及其后的字符，直至按ESC键s：从当前光标位置处开始，以输入的文本替代指定数目的字符S：删除指定数目的行，并以所输入文本代替之ncw或nCW：修改指定数目的字nCC：修改指定数目的行 删除命令ndw或ndW：删除光标处开始及其后的n-1个字do：删至行首d$：删至行尾ndd：删除当前行及其后n-1行x或X：删除一个字符，x删除光标后的，而X删除光标前的Ctrl+u：删除输入方式下所输入的文本 搜索及替换命令/pattern：从光标开始处向文件尾搜索pattern?pattern：从光标开始处向文件首搜索patternn：在同一方向重复上一次搜索命令N：在反方向上重复上一次搜索命令：s/p1/p2/g：将当前行中所有p1均用p2替代：n1,n2s/p1/p2/g：将第n1至n2行中所有p1均用p2替代：g/p1/s//p2/g：将文件中所有p1均用p2替换 选项设置all：列出所有选项设置情况term：设置终端类型ignorance：在搜索中忽略大小写list：显示制表位(Ctrl+I)和行尾标志（$)number：显示行号report：显示由面向行的命令修改过的数目terse：显示简短的警告信息warn：在转到别的文件时若没保存当前文件则显示NO write信息nomagic：允许在搜索模式中，使用前面不带“\\”的特殊字符nowrapscan：禁止vi在搜索到达文件两端时，又从另一端开始mesg：允许vi显示其他用户用write写到自己终端上的信息 最后行方式命令：n1,n2 co n3：将n1行到n2行之间的内容拷贝到第n3行下：n1,n2 m n3：将n1行到n2行之间的内容移至到第n3行下：n1,n2 d ：将n1行到n2行之间的内容删除：w ：保存当前文件：e filename：打开文件filename进行编辑：x：保存当前文件并退出：q：退出vi：q!：不保存文件并退出vi：!command：执行shell命令command：n1,n2 w!command：将文件中n1行至n2行的内容作为command的输入并执行之，若不指定n1，n2，则表示将整个文件内容作为command的输入：r!command：将命令command的输出结果放到当前行 寄存器操作“?nyy：将当前行及其下n行的内容保存到寄存器？中，其中?为一个字母，n为一个数字“?nyw：将当前行及其下n个字保存到寄存器？中，其中?为一个字母，n为一个数字“?nyl：将当前行及其下n个字符保存到寄存器？中，其中?为一个字母，n为一个数字“?p：取出寄存器？中的内容并将其放到光标位置处。这里？可以是一个字母，也可以是一个数字ndd：将当前行及其下共n行文本删除，并将所删内容放到1号删除寄存器中。 参考资料","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://gaianote.github.io/tags/linux/"}]},{"title":"ssh原理及应用","slug":"ssh原理及应用","date":"2017-05-09T02:26:16.000Z","updated":"2017-05-24T16:00:01.159Z","comments":true,"path":"2017/05/09/ssh原理及应用/","link":"","permalink":"http://gaianote.github.io/2017/05/09/ssh原理及应用/","excerpt":"","text":"什么是SSH？简单说，SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。 最基本的用法SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了。 1$ ssh user@host 如果本地用户名与远程用户名一致，登录时可以省略用户名。 1$ ssh host SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口。 1$ ssh -p 2222 user@host 上面这条命令表示，ssh直接连接远程主机的2222端口。 公钥登录使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个： 生成公钥 1$ ssh-keygen 运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。运行结束以后，在 $HOME/.ssh/ 目录下，会新生成两个文件：id_rsa.pub 和 id_rsa。前者是你的公钥，后者是你的私钥。 这时再输入下面的命令，将公钥传送到远程主机host上面： 发送公钥 1$ ssh-copy-id user@host 好了，从此你再登录，就不需要输入密码了。 scpscp用于本地主机和远程主机之间进行文件传输，常用的有以下命令： 本地文件复制到远程复制文件 1scp -P 2222 local_filename root@host:remote_filename 复制目录 1scp -P 2222 -r local_folder root@host:remote_folder 远程文件复制到本地复制文件 1scp -P 2222 root@host:remote_filename local_filename 复制目录 1scp -P 2222 -r root@host:remote_folder local_folder 参数说明 -v 和大多数 linux 命令中的 -v 意思一样 , 用来显示进度 . 可以用来查看连接 , 认证 , 或是配置错误 . -C 使能压缩选项 . -P 选择端口 . 注意 -p 已经被 rcp 使用 . -4 强行使用 IPV4 地址 . -6 强行使用 IPV6 地址 . 参考资料SSH原理与运用（一）：远程登录","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://gaianote.github.io/tags/linux/"}]},{"title":"node基础教程之http模块","slug":"node基础教程之http模块","date":"2017-05-08T03:22:30.000Z","updated":"2017-05-16T02:52:15.382Z","comments":true,"path":"2017/05/08/node基础教程之http模块/","link":"","permalink":"http://gaianote.github.io/2017/05/08/node基础教程之http模块/","excerpt":"","text":"第一个http服务器要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。 request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息； response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。 用Node.js实现一个HTTP服务器程序非常简单。我们来实现一个最简单的Web程序hello.js，它对于所有请求，都返回Hello world!： 123456789101112131415161718const http = require('http');const server = http.createServer((req, res) =&gt; &#123; // 回调函数接收request和response对象, // 获得HTTP请求的method和url: console.log(req.method + ': ' + req.url); // 将HTTP响应200写入response, 同时设置Content-Type: text/html: res.writeHead(200, &#123;'Content-Type': 'text/html'&#125;); // 将HTTP响应的正文写入response: res.end('&lt;h1&gt;Hello world!&lt;/h1&gt;');&#125;);//错误处理server.on('clientError', (err, socket) =&gt; &#123; socket.end('HTTP/1.1 400 Bad Request\\r\\n\\r\\n');&#125;);// 让服务器监听8080端口:server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 在命令提示符下运行该程序，可以看到以下输出： 12$ node hello.jsServer is running at http://127.0.0.1:8080/ 不要关闭命令提示符，直接打开浏览器输入http://localhost:8080，即可在浏览器看到服务器响应的内容Hello world： 同时，在命令提示符窗口，可以看到程序打印的请求信息： 12GET: /GET: /favicon.ico 这就是我们编写的第一个HTTP服务器程序！ 文件服务器我们需要使用 nodejs 提供的 url 模块对 req.url 进行解析，使用 fs 模块对文件进行处理 解析url12var url = require('url');console.log(url.parse('http://user:pass@host.com:8080/path/to/file?query=string#hash')); 结果如下： 12345678910111213Url &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/path/to/file', path: '/path/to/file?query=string', href: 'http://user:pass@host.com:8080/path/to/file?query=string#hash' &#125; 构建文件服务器文件结构如下 12|-index.html|-file-server.js index.html 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello world!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; file-server.js 1234567891011121314151617181920212223242526272829const fs = require('fs'), url = require('url'), path = require('path'), http = require('http');const server = http.createServer((req, res) =&gt; &#123; //通过req.url得到本地对应的文件路径 const pathname = url.parse(req.url).pathname; const filepath = path.join(__dirname, pathname); fs.stat(filepath, (err, stats) =&gt; &#123; if (!err &amp;&amp; stats.isFile()) &#123; //如果文件存在并且未出现错误，读取文件并传给res console.log('200 ' + req.url); res.writeHead(200); fs.createReadStream(filepath).pipe(res); &#125; else &#123; //否则返回404错误 console.log('404 ' + req.url); res.writeHead(404); res.end('404 Not Found'); &#125; &#125;);&#125;);server.listen(8080);console.log('Server is running at http://127.0.0.1:8080/'); 当我们使用浏览器访问 http://127.0.0.1:8080/index.html 时，可以看到 hello world！ 字样，访问其他路径时，会得到 404 not found 的提示 发送请求get()get 方法用于发送 GET 请求,使用格式如下（详细用法件request） 1http.get(options[, callback]) 1234567891011121314151617181920function getTestPersonaLoginCredentials(callback) &#123; return http.get(&#123; host: 'personatestuser.org', path: '/email' &#125;, function(response) &#123; var body = ''; response.on('data', function(d) &#123; body += d; &#125;); response.on('end', function() &#123; var parsed = JSON.parse(body); callback(&#123; email: parsed.email, password: parsed.pass &#125;); &#125;); &#125;);&#125;, request()request方法用于发出HTTP请求，它的使用格式如下。 1http.request(options[, callback]) request方法的options参数，可以是一个对象，也可以是一个字符串。如果是字符串，就表示这是一个URL，Node内部就会自动调用url.parse()，处理这个参数。 options对象可以设置如下属性: host：HTTP请求所发往的域名或者IP地址，默认是localhost。 hostname：该属性会被url.parse()解析，优先级高于host。 port：远程服务器的端口，默认是80。 localAddress：本地网络接口。 socketPath：Unix网络套接字，格式为host:port或者socketPath。 method：指定HTTP请求的方法，格式为字符串，默认为GET。 path：指定HTTP请求的路径，默认为根路径（/）。可以在这个属性里面，指定查询字符串，比如/index.html?page=12。如果这个属性里面包含非法字符（比如空格），就会抛出一个错误。 headers：一个对象，包含了HTTP请求的头信息。 auth：一个代表HTTP基本认证的字符串user:password。 agent：控制缓存行为，如果HTTP请求使用了agent，则HTTP请求默认为Connection: keep-alive，它的可能值如下： undefined（默认）：对当前host和port，使用全局Agent。 Agent：一个对象，会传入agent属性。 false：不缓存连接，默认HTTP请求为Connection: close。 keepAlive：一个布尔值，表示是否保留socket供未来其他请求使用，默认等于false。 keepAliveMsecs：一个整数，当使用KeepAlive的时候，设置多久发送一个TCP KeepAlive包，使得连接不要被关闭。默认等于1000，只有keepAlive设为true的时候，该设置才有意义。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"http教程","slug":"http教程","date":"2017-05-08T02:59:54.000Z","updated":"2017-05-16T02:52:15.267Z","comments":true,"path":"2017/05/08/http教程/","link":"","permalink":"http://gaianote.github.io/2017/05/08/http教程/","excerpt":"","text":"HTTP教程HTTP协议（HyperText Transfer Protocol，超文本传输协议）是因特网上应用最为广泛的一种网络传输协议，所有的WWW文件都必须遵守这个标准。HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 HTTP消息结构客户端请求消息 客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文 客户端请求： 1234GET /hello.txt HTTP/1.1User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3Host: www.example.comAccept-Language: en, mi 服务端响应: 123456789HTTP/1.1 200 OKDate: Mon, 27 Jul 2009 12:28:53 GMTServer: ApacheLast-Modified: Wed, 22 Jul 2009 19:15:56 GMTETag: &quot;34aa387-d-1568eb00&quot;Accept-Ranges: bytesContent-Length: 51Vary: Accept-EncodingContent-Type: text/plain HTTP请求方法根据HTTP标准，HTTP请求可以使用多种请求方法。 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法。 GET 请求指定的页面信息，并返回实体主体。 HEAD 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 DELETE 请求服务器删除指定的页面。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 允许客户端查看服务器的性能。 TRACE 回显服务器收到的请求，主要用于测试或诊断。","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://gaianote.github.io/tags/http/"}]},{"title":"HTTP代理原理及实现","slug":"HTTP代理原理及实现","date":"2017-05-08T02:02:14.000Z","updated":"2017-05-16T02:52:15.220Z","comments":true,"path":"2017/05/08/HTTP代理原理及实现/","link":"","permalink":"http://gaianote.github.io/2017/05/08/HTTP代理原理及实现/","excerpt":"","text":"普通代理服务器普通代理服务器充当中间人的角色，对于连接到它的客户端来说，它是服务端；对于要连接的服务端来说，它是客户端。它就负责在两端之间来回传送 HTTP 报文。 1234567891011121314151617181920212223242526const http = require('http');const net = require('net');const url = require('url');function request(cReq, cRes) &#123; const u = url.parse(cReq.url); const options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers &#125;; // 解析options，新建到服务端的请求 const pReq = http.request(options, function(pRes) &#123; cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); &#125;).on('error', function(e) &#123; cRes.end(); &#125;); // 把代理收到的请求转发给新建的请求 cReq.pipe(pReq);&#125;http.createServer().on('request', request).listen(8888, '0.0.0.0'); 以上代码运行后，会在本地 8888 端口开启 HTTP 代理服务，这个服务从请求报文中解析出请求 URL 和其他必要参数，新建到服务端的请求，并把代理收到的请求转发给新建的请求，最后再把服务端响应返回给浏览器。修改浏览器的 HTTP 代理为 127.0.0.1:8888 后再访问 HTTP 网站，代理可以正常工作。 这个代理提供的是 HTTP 服务，没办法承载 HTTPS 服务 ，HTTPS 代理需要使用隧道代理实现 隧道代理HTTP 客户端通过 CONNECT 方法请求隧道代理创建一条到达任意目的服务器和端口的 TCP 连接，并对客户端和服务器之间的后继数据进行盲转发。 123456789101112131415161718const http = require('http');const net = require('net');const url = require('url');function connect(cReq, cSock) &#123; const u = url.parse('http://' + cReq.url); const pSock = net.connect(u.port, u.hostname, function() &#123; cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); &#125;).on('error', function(e) &#123; cSock.end(); &#125;); cSock.pipe(pSock);&#125;http.createServer().on('connect', connect).listen(8888, '0.0.0.0'); 隧道代理主要用于 https ，因此我们将上述两段代码合二为一,同时处理 http 与 https 请求 123456789101112131415161718192021222324252627282930313233343536373839404142var http = require('http');var net = require('net');var url = require('url');function request(cReq, cRes) &#123; var u = url.parse(cReq.url); var options = &#123; hostname : u.hostname, port : u.port || 80, path : u.path, method : cReq.method, headers : cReq.headers &#125;; var pReq = http.request(options, function(pRes) &#123; cRes.writeHead(pRes.statusCode, pRes.headers); pRes.pipe(cRes); &#125;).on('error', function(e) &#123; cRes.end(); &#125;); cReq.pipe(pReq);&#125;function connect(cReq, cSock) &#123; var u = url.parse('http://' + cReq.url); var pSock = net.connect(u.port, u.hostname, function() &#123; cSock.write('HTTP/1.1 200 Connection Established\\r\\n\\r\\n'); pSock.pipe(cSock); &#125;).on('error', function(e) &#123; cSock.end(); &#125;); cSock.pipe(pSock);&#125;http.createServer() .on('request', request) .on('connect', connect) .listen(8888, '0.0.0.0'); 参考资料HTTP 代理原理及实现","categories":[],"tags":[]},{"title":"ReactNative搭建1开发环境","slug":"ReactNative搭建1开发环境","date":"2017-05-05T09:05:51.000Z","updated":"2017-05-16T02:52:15.239Z","comments":true,"path":"2017/05/05/ReactNative搭建1开发环境/","link":"","permalink":"http://gaianote.github.io/2017/05/05/ReactNative搭建1开发环境/","excerpt":"","text":"参考资料","categories":[],"tags":[]},{"title":"sequelize和mysql对照","slug":"sequelize和mysql对照","date":"2017-05-04T13:54:15.000Z","updated":"2017-05-16T02:52:15.435Z","comments":true,"path":"2017/05/04/sequelize和mysql对照/","link":"","permalink":"http://gaianote.github.io/2017/05/04/sequelize和mysql对照/","excerpt":"","text":"建立数据库连接1234567891011121314var sequelize = new Sequelize( 'dbname', // 数据库名 'username', // 用户名 'password', // 用户密码 &#123; 'dialect': 'mysql', // 数据库使用mysql 'host': 'localhost', // 数据库服务器ip 'port': 3306, // 数据库服务器端口 'define': &#123; // 字段以下划线（_）来分割（默认是驼峰命名风格） 'underscored': true &#125; &#125;); 定义单张表123456789101112131415161718192021var User = sequelize.define( // 默认表名（一般这里写单数），生成时会自动转换成复数形式 // 这个值还会作为访问模型相关的模型时的属性名，所以建议用小写形式 'user', // 字段定义（主键、created_at、updated_at默认包含，不用特殊定义） &#123; 'emp_id': &#123; 'type': Sequelize.CHAR(10), // 字段类型 'allowNull': false, // 是否允许为NULL 'unique': true // 字段是否UNIQUE(唯一) &#125;, 'nick': &#123; 'type': Sequelize.CHAR(10), 'allowNull': false &#125;, 'department': &#123; 'type': Sequelize.STRING(64), 'allowNull': true &#125; &#125;); 单表增删改查通过Sequelize获取的模型对象都是一个DAO（Data Access Object）对象，这些对象会拥有许多操作数据库表的实例对象方法（比如：save、update、destroy等），需要获取“干净”的JSON对象可以调用get({‘plain’: true})。 通过模型的类方法可以获取模型对象（比如：findById、findAll等）。 增Sequelize： 12345678910111213141516// 方法1：build后对象只存在于内存中，调用save后才操作dbvar user = User.build(&#123; 'emp_id': '1', 'nick': '小红', 'department': '技术部'&#125;);user = await user.save();console.log(user.get(&#123;'plain': true&#125;));// 方法2：直接操作dbvar user = await User.create(&#123; 'emp_id': '2', 'nick': '小明', 'department': '技术部'&#125;);console.log(user.get(&#123;'plain': true&#125;)); Sequelize会为主键 id 设置 DEFAULT 值来让数据库产生自增值，还将当前时间设置成了 created_at 和 updated_at 字段，非常方便。 改12345678910// 方法1：操作对象属性（不会操作db），调用save后操作dbuser.nick = '小白';user = await user.save();console.log(user.get(&#123;'plain': true&#125;));// 方法2：直接update操作dbuser = await user.update(&#123; 'nick': '小白白'&#125;);console.log(user.get(&#123;'plain': true&#125;)); 更新操作时，Sequelize将将当前时间设置成了updated_at，非常方便。 如果想限制更新属性的白名单，可以这样写： 12345678910// 方法1user.emp_id = '33';user.nick = '小白';user = await user.save(&#123;'fields': ['nick']&#125;);// 方法2user = await user.update( &#123;'emp_id': '33', 'nick': '小白'&#125;, &#123;'fields': ['nick']&#125;&#125;); 这样就只会更新nick字段，而emp_id会被忽略。这种方法在对表单提交过来的一大推数据中只更新某些属性的时候比较有用。 删1await user.destroy(); 这里有个特殊的地方是，如果我们开启了paranoid（偏执）模式，destroy的时候不会执行DELETE语句，而是执行一个UPDATE语句将deleted_at字段设置为当前时间（一开始此字段值为NULL）。我们可以使用user.destroy({force: true})来强制删除，从而执行DELETE语句进行物理删除。 查查全部 12var users = await User.findAll();console.log(users); 限制字段 1234var users = await User.findAll(&#123; 'attributes': ['emp_id', 'nick']&#125;);console.log(users); 字段重命名 123456var users = await User.findAll(&#123; 'attributes': [ 'emp_id', ['nick', 'user_nick'] ]&#125;);console.log(users); where子句Sequelize的where配置项基本上完全支持了SQL的where子句的功能，非常强大。我们一步步来进行介绍。 基本条件12345678var users = await User.findAll(&#123; 'where': &#123; 'id': [1, 2, 3], 'nick': 'a', 'department': null &#125;&#125;);console.log(users); 操作符操作符是对某个字段的进一步约束，可以有多个（对同一个字段的多个操作符会被转化为AND）。 Sequelize： 12345678910111213141516171819202122232425262728var users = await User.findAll(&#123; 'where': &#123; 'id': &#123; '$eq': 1, // id = 1 '$ne': 2, // id != 2 '$gt': 6, // id &gt; 6 '$gte': 6, // id &gt;= 6 '$lt': 10, // id &lt; 10 '$lte': 10, // id &lt;= 10 '$between': [6, 10], // id BETWEEN 6 AND 10 '$notBetween': [11, 15], // id NOT BETWEEN 11 AND 15 '$in': [1, 2], // id IN (1, 2) '$notIn': [3, 4] // id NOT IN (3, 4) &#125;, 'nick': &#123; '$like': '%a%', // nick LIKE '%a%' '$notLike': '%a' // nick NOT LIKE '%a' &#125;, 'updated_at': &#123; '$eq': null, // updated_at IS NULL '$ne': null // created_at IS NOT NULL &#125; &#125;&#125;); 条件上面我们说的条件查询，都是AND查询，Sequelize同时也支持OR、NOT、甚至多种条件的联合查询。 AND条件 12345678var users = await User.findAll(&#123; 'where': &#123; '$and': [ &#123;'id': [1, 2]&#125;, &#123;'nick': null&#125; ] &#125;&#125;); OR条件 12345678var users = await User.findAll(&#123; 'where': &#123; '$or': [ &#123;'id': [1, 2]&#125;, &#123;'nick': null&#125; ] &#125;&#125;); NOT条件 12345678var users = await User.findAll(&#123; 'where': &#123; '$not': [ &#123;'id': [1, 2]&#125;, &#123;'nick': null&#125; ] &#125;&#125;); 批量操作插入 1234567var users = yield User.bulkCreate( [ &#123;'emp_id': 'a', 'nick': 'a'&#125;, &#123;'emp_id': 'b', 'nick': 'b'&#125;, &#123;'emp_id': 'c', 'nick': 'c'&#125; ]); 这里需要注意，返回的users数组里面每个对象的id值会是null。如果需要id值，可以重新取下数据。 更新 12345678var affectedRows = yield User.update( &#123;'nick': 'hhhh'&#125;, &#123; 'where': &#123; 'id': [2, 3, 4] &#125; &#125;); 删除 123var affectedRows = yield User.destroy(&#123; 'where': &#123;'id': [2, 3, 4]&#125;&#125;); 关系关系一般有三种：一对一、一对多、多对多。Sequelize提供了清晰易用的接口来定义关系、进行表间的操作。 一对一模型定义1234567891011121314151617181920212223242526var User = sequelize.define('user', &#123; 'emp_id': &#123; 'type': Sequelize.CHAR(10), 'allowNull': false, 'unique': true &#125; &#125;);var Account = sequelize.define('account', &#123; 'email': &#123; 'type': Sequelize.CHAR(20), 'allowNull': false &#125; &#125;);/* * User的实例对象将拥有getAccount、setAccount、addAccount方法 */User.hasOne(Account);/* * Account的实例对象将拥有getUser、setUser、addUser方法 */Account.belongsTo(User); 可以看到，这种关系中外键user_id加在了Account上。另外，Sequelize还给我们生成了外键约束。 一般来说，外键约束在有些自己定制的数据库系统里面是禁止的，因为会带来一些性能问题。所以，建表的SQL一般就去掉约束，同时给外键加一个索引（加速查询），数据的一致性就靠应用层来保证了。 关系操作增 123var user = yield User.create(&#123;'emp_id': '1'&#125;);var account = user.createAccount(&#123;'email': 'a'&#125;);console.log(account.get(&#123;'plain': true&#125;)); 改 1234var anotherAccount = yield Account.create(&#123;'email': 'b'&#125;);console.log(anotherAccount);anotherAccount = yield user.setAccount(anotherAccount);console.log(anotherAccount); 删 1yield user.setAccount(null); 查 12var account = yield user.getAccount();console.log(account); 这里就是调用user的getAccount方法，根据外键来获取对应的account。 但是其实我们用面向对象的思维来思考应该是获取user的时候就能通过user.account的方式来访问account对象。这可以通过Sequelize的eager loading（急加载，和懒加载相反）来实现。 eager loading的含义是说，取一个模型的时候，同时也把相关的模型数据也给我取过来（我很着急，不能按默认那种取一个模型就取一个模型的方式，我还要更多）。方法如下： 1234567891011121314151617var user = yield User.findById(1, &#123; 'include': [Account]&#125;);console.log(user.get(&#123;'plain': true&#125;));/* * 输出类似： &#123; id: 1, emp_id: '1', created_at: Tue Nov 03 2015 15:25:27 GMT+0800 (CST), updated_at: Tue Nov 03 2015 15:25:27 GMT+0800 (CST), account: &#123; id: 2, email: 'b', created_at: Tue Nov 03 2015 15:25:27 GMT+0800 (CST), updated_at: Tue Nov 03 2015 15:25:27 GMT+0800 (CST), user_id: 1 &#125; &#125; */ 可以看到，我们对2个表进行了一个外联接，从而在取user的同时也获取到了account。 其他补充说明 如果我们重复调用user.createAccount方法，实际上会在数据库里面生成多条user_id一样的数据，并不是真正的一对一。 所以，在应用层保证一致性时，就需要我们遵循良好的编码约定。新增就用user.createAccount，更改就用user.setAccount。 也可以给user_id加一个UNIQUE约束，在数据库层面保证一致性，这时就需要做好try/catch，发生插入异常的时候能够知道是因为插入了多个account。 另外，我们上面都是使用user来对account进行操作。实际上反向操作也是可以的，这是因为我们定义了Account.belongsTo(User)。在Sequelize里面定义关系时，关系的调用方会获得相关的“关系”方法，一般为了两边都能操作，会同时定义双向关系（这里双向关系指的是模型层面，并不会在数据库表中出现两个表都加上外键的情况，请放心）。 一对多模型定义1234567891011121314151617181920212223242526var User = sequelize.define('user', &#123; 'emp_id': &#123; 'type': Sequelize.CHAR(10), 'allowNull': false, 'unique': true &#125; &#125;);var Note = sequelize.define('note', &#123; 'title': &#123; 'type': Sequelize.CHAR(64), 'allowNull': false &#125; &#125;);/* * User的实例对象将拥有getNotes、setNotes、addNote、createNote、removeNote、hasNote方法 */User.hasMany(Note);/* * Note的实例对象将拥有getUser、setUser、createUser方法 */Note.belongsTo(User); 关系操作增 12345678//方法1var user = yield User.create(&#123;'emp_id': '1'&#125;);var note = yield user.createNote(&#123;'title': 'a'&#125;);console.log(note);//方法2var user = yield User.create(&#123;'emp_id': '1'&#125;);var note = yield Note.create(&#123;'title': 'b'&#125;);yield user.addNote(note); 改 123456789// 为user增加note1、note2var user = yield User.create(&#123;'emp_id': '1'&#125;);var note1 = yield user.createNote(&#123;'title': 'a'&#125;);var note2 = yield user.createNote(&#123;'title': 'b'&#125;);// 先创建note3、note4var note3 = yield Note.create(&#123;'title': 'c'&#125;);var note4 = yield Note.create(&#123;'title': 'd'&#125;);// user拥有的note更改为note3、note4yield user.setNotes([note3, note4]); 删 1yield user.removeNote(note); 查 情况1 查询user的所有满足条件的note数据。 12345678910var notes = yield user.getNotes(&#123; 'where': &#123; 'title': &#123; '$like': '%css%' &#125; &#125;&#125;);notes.forEach(function(note) &#123; console.log(note);&#125;); 情况2 查询所有满足条件的note，同时获取note属于哪个user。 123456789101112var notes = yield Note.findAll(&#123; 'include': [User], 'where': &#123; 'title': &#123; '$like': '%css%' &#125; &#125;&#125;);notes.forEach(function(note) &#123; // note属于哪个user可以通过note.user访问 console.log(note);&#125;); 情况3 查询所有满足条件的user，同时获取该user所有满足条件的note。 123456789101112var users = yield User.findAll(&#123; 'include': [Note], 'where': &#123; 'created_at': &#123; '$lt': new Date() &#125; &#125;&#125;);users.forEach(function(user) &#123; // user的notes可以通过user.notes访问 console.log(user);&#125;); 多对多关系在多对多关系中，必须要额外一张关系表来将2个表进行关联，这张表可以是单纯的一个关系表，也可以是一个实际的模型（含有自己的额外属性来描述关系）。我比较喜欢用一个模型的方式，这样方便以后做扩展。 模型定义123456789101112131415161718192021222324252627282930var Note = sequelize.define('note', &#123; 'title': &#123; 'type': Sequelize.CHAR(64), 'allowNull': false &#125; &#125;);var Tag = sequelize.define('tag', &#123; 'name': &#123; 'type': Sequelize.CHAR(64), 'allowNull': false, 'unique': true &#125; &#125;);var Tagging = sequelize.define('tagging', &#123; 'type': &#123; 'type': Sequelize.INTEGER(), 'allowNull': false &#125; &#125;);// Note的实例拥有getTags、setTags、addTag、addTags、createTag、removeTag、hasTag方法Note.belongsToMany(Tag, &#123;'through': Tagging&#125;);// Tag的实例拥有getNotes、setNotes、addNote、addNotes、createNote、removeNote、hasNote方法Tag.belongsToMany(Note, &#123;'through': Tagging&#125;); 增 方法1 12var note = yield Note.create(&#123;'title': 'note'&#125;);yield note.createTag(&#123;'name': 'tag'&#125;, &#123;'type': 0&#125;); 方法2 123var note = yield Note.create(&#123;'title': 'note'&#125;);var tag = yield Tag.create(&#123;'name': 'tag'&#125;);yield note.addTag(tag, &#123;'type': 1&#125;); 方法3 1234var note = yield Note.create(&#123;'title': 'note'&#125;);var tag1 = yield Tag.create(&#123;'name': 'tag1'&#125;);var tag2 = yield Tag.create(&#123;'name': 'tag2'&#125;);yield note.addTags([tag1, tag2], &#123;'type': 2&#125;); 改 123456789// 先添加几个tagvar note = yield Note.create(&#123;'title': 'note'&#125;);var tag1 = yield Tag.create(&#123;'name': 'tag1'&#125;);var tag2 = yield Tag.create(&#123;'name': 'tag2'&#125;);yield note.addTags([tag1, tag2], &#123;'type': 2&#125;);// 将tag改掉var tag3 = yield Tag.create(&#123;'name': 'tag3'&#125;);var tag4 = yield Tag.create(&#123;'name': 'tag4'&#125;);yield note.setTags([tag3, tag4], &#123;'type': 3&#125;); 删 123456789101112// 先添加几个tagvar note = yield Note.create(&#123;'title': 'note'&#125;);var tag1 = yield Tag.create(&#123;'name': 'tag1'&#125;);var tag2 = yield Tag.create(&#123;'name': 'tag2'&#125;);var tag3 = yield Tag.create(&#123;'name': 'tag2'&#125;);yield note.addTags([tag1, tag2, tag3], &#123;'type': 2&#125;);// 删除一个yield note.removeTag(tag1);// 全部删除yield note.setTags([]); 删除一个很简单，直接将关系表中的数据删除。 全部删除时，首先需要查出关系表中note_id对应的所有数据，然后一次删掉。 查 情况1 查询note所有满足条件的tag。 1234567var tags = yield note.getTags(&#123; //这里可以对tags进行where&#125;);tags.forEach(function(tag) &#123; // 关系模型可以通过tag.tagging来访问 console.log(tag);&#125;); 情况2 查询所有满足条件的tag，同时获取每个tag所在的note。 12345678910111213var tags = yield Tag.findAll(&#123; 'include': [ &#123; 'model': Note // 这里可以对notes进行where &#125; ] // 这里可以对tags进行where&#125;);tags.forEach(function(tag) &#123; // tag的notes可以通过tag.notes访问，关系模型可以通过tag.notes[0].tagging访问 console.log(tag);&#125;); 情况3 查询所有满足条件的note，同时获取每个note所有满足条件的tag。 12345678910111213var notes = yield Note.findAll(&#123; 'include': [ &#123; 'model': Tag // 这里可以对tags进行where &#125; ] // 这里可以对notes进行where&#125;);notes.forEach(function(note) &#123; // note的tags可以通过note.tags访问，关系模型通过note.tags[0].tagging访问 console.log(note);&#125;); 参考资料sequelize和mysql对照","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://gaianote.github.io/tags/mysql/"}]},{"title":"koa2学习系列教程7 koa与REST规范","slug":"koa2学习系列教程7koa与REST规范","date":"2017-05-03T03:17:15.000Z","updated":"2017-05-16T02:52:15.315Z","comments":true,"path":"2017/05/03/koa2学习系列教程7koa与REST规范/","link":"","permalink":"http://gaianote.github.io/2017/05/03/koa2学习系列教程7koa与REST规范/","excerpt":"","text":"hello RESTREST描述的是在网络中client和server的一种交互形式，它要求我们用 URL 定位资源，用 HTTP 动词（GET,POST,DELETE,DETC）描述操作。 12345rest-hello|-controller| |-api.js # 符合 REST 规范的 product 信息管理|-app.js|-controller.js 我们在 api.js 内实现 REST 规范，用于管理 product 信息，当 GET 请求 /api/products 时，返回包含product信息的 json 字符串，当 POST 请求 /api/products 时，将新产品添加到产品列表。信息交流统一以 json 格式进行 api.js 1234567891011121314151617181920212223242526272829//用于模拟数据库，储存products产品信息，简化流程var products = [&#123; name: 'iPhone', price: 6999&#125;, &#123; name: 'Kindle', price: 999&#125;];module.exports = &#123; //获取商品信息 'GET /api/products': async (ctx, next) =&gt; &#123; ctx.response.type = 'application/json'; ctx.response.body = &#123; products: products &#125;; &#125;, //新增商品 'POST /api/products': async (ctx, next) =&gt; &#123; var p = &#123; name: ctx.request.body.name, price: ctx.request.body.price &#125;; products.push(p); ctx.response.type = 'application/json'; ctx.response.body = p; &#125;&#125;; REST规范http请求规范REST 规范定义了资源的通用访问格式，虽然它不是一个强制要求，但遵守该规范可以让人易于理解。 GET 用于获取资源 POST 用于新建资源 PUT 用于更新资源 DELETE 用于删除资源 例如，商品Product就是一种资源。获取所有Product的URL如下： 1GET /api/products 而获取某个指定的Product，例如，id为123的Product，其URL如下： 1GET /api/products/123 新建一个Product使用POST请求，JSON数据包含在body中，URL如下： 1POST /api/products 更新一个Product使用PUT请求，例如，更新id为123的Product，其URL如下： 1PUT /api/products/123 删除一个Product使用DELETE请求，例如，删除id为123的Product，其URL如下： 1DELETE /api/products/123 资源还可以按层次组织。例如，获取某个Product的所有评论，使用： 1GET /api/products/123/reviews 当我们只需要获取部分数据时，可通过参数限制返回的结果集，例如，返回第2页评论，每页10项，按时间排序： 1GET /api/products/123/reviews?page=2&amp;size=10&amp;sort=time URL 与数据通信格式约定在实际工程中，一个Web应用既有REST，还有MVC，可能还需要集成其他第三方系统。如何组织URL？ 为了利于开发与实际应用，我们进行如下规定: REST API的返回值全部是object对象，而不是简单的number、boolean、null或者数组； REST API必须使用前缀/api/ 封装 ctx.rest() 输出 json 数据定义 rest.restify 中间件每次输出 json 数据时，都要使用 ctx.response.type = &#39;application/json&#39;; 不够又优雅，我们可以可以通过一个 middleware 给 ctx 添加一个 rest() 方法，直接输出JSON数据 12345678910111213141516module.exports = &#123; restify: (pathPrefix) =&gt; &#123; pathPrefix = pathPrefix || '/api/'; return async (ctx, next) =&gt; &#123; if (ctx.request.path.startsWith(pathPrefix)) &#123; console.log(`Process API $&#123;ctx.request.method&#125; $&#123;ctx.request.url&#125;...`); ctx.rest = (data) =&gt; &#123; ctx.response.type = 'application/json'; ctx.response.body = data; &#125; &#125; else &#123; await next(); &#125; &#125;; &#125;&#125;; 此后，输出json数据时，使用 ctx.rest(data) 即可 使用 rest.restify 中间件在 app.js 中调用中间件 12const rest = require('./rest');app.use(rest.restify()); 在 api.js 中使用 ctx.rest(data) 输出json数据 1234ctx.rest(&#123;products: products&#125;)//等价于ctx.response.type = 'application/json';ctx.response.body = &#123;products: products&#125;; 错误处理两种错误类型在涉及到REST API的错误时，我们必须先意识到，客户端会遇到两种类型的REST API错误。 403，404，500等错误 这些错误实际上是HTTP请求可能发生的错误。REST请求只是一种请求类型和响应类型均为JSON的HTTP请求，因此，这些错误在REST请求中也会发生。针对这种类型的错误，客户端除了提示用户“出现了网络错误，稍后重试”以外，并无法获得具体的错误信息。 业务逻辑错误 例如，输入了不合法的Email地址，试图删除一个不存在的Product，等等。这种类型的错误完全可以通过JSON返回给客户端，这样，客户端可以根据错误信息提示用户“Email不合法”等，以便用户修复后重新请求API。 错误响应第一类的错误实际上客户端可以识别，并且我们也无法操控HTTP服务器的错误码。 第二类的错误信息是一个JSON字符串，例如： 1234&#123; \"code\": \"10000\", \"message\": \"Bad email address\"&#125; 对于第二类错误的 HTTP 返回码，我们做出如下约定：正确的REST响应使用 200，对错误的REST响应使用 400 但是，要注意，绝不能混合其他HTTP错误码。例如，使用401响应“登录失败”，使用403响应“权限不够”。这会使客户端无法有效识别HTTP错误码和业务错误，，其原因在于HTTP协议定义的错误码十分偏向底层，而REST API属于“高层”协议，不应该复用底层的错误码。 定义错误码我们约定使用字符串作为错误码。原因在于，使用数字作为错误码时，API提供者需要维护一份错误码代码说明表，并且，该文档必须时刻与API发布同步，否则，客户端开发者遇到一个文档上没有写明的错误码，就完全不知道发生了什么错误。 我们定义的REST API错误格式如下： 1234&#123; &quot;code&quot;: &quot;错误代码&quot;, &quot;message&quot;: &quot;错误描述信息&quot;&#125; 其中，错误代码命名规范为大类:子类，例如，口令不匹配的登录错误代码为 auth:bad_password，用户名不存在的登录错误代码为 auth:user_not_found。这样，客户端既可以简单匹配某个类别的错误，也可以精确匹配某个特定的错误。 返回错误使用ctx.rest()返回错误 如果一个REST异步函数想要返回错误，一个直观的想法是调用ctx.rest()： 12345678910user = processLogin(username, password);if (user != null) &#123; ctx.rest(user);&#125; else &#123; ctx.response.status = 400; ctx.rest(&#123; code: 'auth:user_not_found', message: 'user not found' &#125;);&#125; 这种方式不好，因为控制流程会混乱，而且，错误只能在Controller函数中输出。 使用throw语句抛出错误 更好的方式是异步函数直接用throw语句抛出错误，让middleware去处理错误： 123456user = processLogin(username, password);if (user != null) &#123; ctx.rest(user);&#125; else &#123; throw new APIError('auth:user_not_found', 'user not found');&#125; 这种方式可以在异步函数的任何地方抛出错误，包括调用的子函数内部。 我们只需要稍稍改写一个middleware就可以处理错误： 12345678910111213141516171819202122232425262728293031module.exports = &#123; APIError: function (code, message) &#123; this.code = code || 'internal:unknown_error'; this.message = message || ''; &#125;, restify: (pathPrefix) =&gt; &#123; pathPrefix = pathPrefix || '/api/'; return async (ctx, next) =&gt; &#123; if (ctx.request.path.startsWith(pathPrefix)) &#123; // 绑定rest()方法: ctx.rest = (data) =&gt; &#123; ctx.response.type = 'application/json'; ctx.response.body = data; &#125; try &#123; await next(); &#125; catch (e) &#123; // 返回错误: ctx.response.status = 400; ctx.response.type = 'application/json'; ctx.response.body = &#123; code: e.code || 'internal:unknown_error', message: e.message || '' &#125;; &#125; &#125; else &#123; await next(); &#125; &#125;; &#125;&#125;; 这个错误处理的好处在于，不但简化了Controller的错误处理（只需要throw，其他不管），并且，在遇到非APIError的错误时，自动转换错误码为internal:unknown_error。 受益于async/await语法，我们在middleware中可以直接用try…catch捕获异常。如果是callback模式，就无法用try…catch捕获，代码结构将混乱得多。 最后，顺便把APIError这个对象export出去。 抛出错误 我们在 api.js 中，通过 throw new APIError() 返回错误： 1234567891011module.exports = &#123; 'DELETE /api/products/:id': async (ctx, next) =&gt; &#123; console.log(`delete product $&#123;ctx.params.id&#125;...`); var p = products.deleteProduct(ctx.params.id); if (p) &#123; ctx.rest(p); &#125; else &#123; throw new APIError('product:not_found', 'product not found by id.'); &#125; &#125;&#125;","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"git速查手册","slug":"git速查手册","date":"2017-05-02T06:28:06.000Z","updated":"2017-05-16T02:52:15.263Z","comments":true,"path":"2017/05/02/git速查手册/","link":"","permalink":"http://gaianote.github.io/2017/05/02/git速查手册/","excerpt":"","text":"当一个文件提交了，但是又更新了 .gitignore 文件，可以使用如下方式删除缓存，再重新提交 1git rm --cached file_path 示例，项目文件结构如下： 12345learn-js|-node |-.gitignore |-koa2 |-node_moudles 我未创建 .gitignore 文件便进行提交，之后希望忽略 node_moudles ，只需进行如下操作 1git rm -r --cached node_moudles","categories":[],"tags":[]},{"title":"node模块与commonjs规范","slug":"node模块与commonjs规范","date":"2017-04-28T09:37:19.000Z","updated":"2017-05-16T02:52:15.390Z","comments":true,"path":"2017/04/28/node模块与commonjs规范/","link":"","permalink":"http://gaianote.github.io/2017/04/28/node模块与commonjs规范/","excerpt":"","text":"Node应用由模块组成，采用CommonJS模块规范。 根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 定义模块12345678910// example.jsvar invisible = function () &#123; console.log(\"invisible\");&#125;exports.message = \"hi\";exports.say = function () &#123; console.log(message);&#125; 运行下面的命令，可以输出exports对象。 123456var example = require('./example.js');example// &#123;// message: \"hi\",// say: [Function]// &#125; 如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在module.exports变量上面。 12345module.exports = function () &#123; console.log(\"hello world\")&#125;require('./example2.js')() 上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。 加载规则require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 require 路径规则require命令用于加载文件，后缀名默认为.js。 123var foo = require('foo');// 等同于var foo = require('foo.js'); 根据参数的不同格式，require命令去不同路径寻找模块文件。 如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(‘/home/marco/foo.js’)将加载/home/marco/foo.js。 如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(‘./circle’)将加载当前脚本同一目录的circle.js。 如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。 引入的同时执行了被引入模块son.js 1234console.log(msg)module.exports = function () &#123; console.log(msg)&#125; father.js 123msg = 'hello world'const foo = require('./child')foo() 输出结果为: 12hello worldhello world 模块之间变量不共享","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"koa2学习系列教程6 koa-static静态服务器的搭建","slug":"koa2学习系列教程6koa-static静态服务器的搭建","date":"2017-04-28T05:44:34.000Z","updated":"2017-05-16T02:52:15.308Z","comments":true,"path":"2017/04/28/koa2学习系列教程6koa-static静态服务器的搭建/","link":"","permalink":"http://gaianote.github.io/2017/04/28/koa2学习系列教程6koa-static静态服务器的搭建/","excerpt":"","text":"我们可以使用 koa-static 快速搭建静态服务器，用于访问 koa 服务器内的js，css，img等静态文件。 hello koa-static首先安装 koa-static 1npm install koa-static --save 然后定义 static 服务器文件夹所在目录，这里定义为 ./static , static 文件夹根目录对应网站根目录，里面的内容可以通过 url 直接访问 12const serve = require('koa-static');app.use(serve(__dirname + '/static')); 文件结构1234567hello-koa-static|-views| |-index.html|-static| |-img| |-koa.pngapp.js index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=\"text-align: center;\"&gt; &lt;img src=\"img/koa.png\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; app.js 123456789101112131415161718const Koa = require('koa');const app = new Koa();const nunjucks = require('nunjucks');nunjucks.configure('views', &#123; autoescape: true &#125;);const serve = require('koa-static');app.use(serve(__dirname + '/static'));app.use(async (ctx,next)=&gt;&#123; if (ctx.path === '/') &#123; ctx.body = nunjucks.render('index.html', &#123; title: 'hello koa-static' &#125;) &#125; else &#123; await next; &#125;&#125;)app.listen(3000); 打开 192.168.1.101:3000 可以看到 koa 的 logo 图片 ，同样，我们也可以直接访问 192.168.1.101:3000/img/koa.png 查看此图片。","categories":[],"tags":[{"name":"koa","slug":"koa","permalink":"http://gaianote.github.io/tags/koa/"}]},{"title":"koa2学习系列教程5 模板引擎 Nunjucks","slug":"koa2学习系列教程5模板引擎_Nunjucks","date":"2017-04-27T09:27:43.000Z","updated":"2017-05-16T02:52:15.301Z","comments":true,"path":"2017/04/27/koa2学习系列教程5模板引擎_Nunjucks/","link":"","permalink":"http://gaianote.github.io/2017/04/27/koa2学习系列教程5模板引擎_Nunjucks/","excerpt":"","text":"hello NunjucksNunjucks是Mozilla开发的一个纯JavaScript编写的模板引擎，语法与Python的模板引擎jinja2类似 目录结构1234hello-Nunjucks/|-views # 用于存放模板文件| |-hello.html # HTML模板文件|-app.js # 入口js 安装Nunjucks1npm install Nunjucks --save 开始使用app.js 12345678910const Koa = require('koa');const app = new Koa();const nunjucks = require('nunjucks');nunjucks.configure('views', &#123; autoescape: true &#125;);app.use(ctx =&gt; &#123; ctx.body = nunjucks.render('hello.html', &#123; name: 'nunjucks' &#125;)&#125;);app.listen(3000); hello.html 1&lt;h1&gt;Hello &#123;&#123; name &#125;&#125;&lt;/h1&gt; 启动服务器，打开 http://127.0.0.1:3000/ 就可以看到 Hello nunjucks 的字样，是不是很简单？ 常用语法for遍历一维数组 1var items = [&#123; title: \"foo\", id: 1 &#125;, &#123; title: \"bar\", id: 2&#125;]; 12345678&lt;h1&gt;Posts&lt;/h1&gt;&lt;ul&gt;&#123;% for item in items %&#125; &lt;li&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt;&#123;% else %&#125; &lt;li&gt;This would display if the 'item' collection were empty&lt;/li&gt;&#123;% endfor %&#125;&lt;/ul&gt; 遍历二维数组 1var points = [[0, 1, 2], [5, 6, 7], [12, 13, 14]]; 123&#123;% for x, y, z in points %&#125; Point: &#123;&#123; x &#125;&#125;, &#123;&#123; y &#125;&#125;, &#123;&#123; z &#125;&#125;&#123;% endfor %&#125; 遍历字典 12345var food = &#123; 'ketchup': '5 tbsp', 'mustard': '1 tbsp', 'pickle': '0 tbsp'&#125;; 123&#123;% for ingredient, amount in food %&#125; Use &#123;&#123; amount &#125;&#125; of &#123;&#123; ingredient &#125;&#125;&#123;% endfor %&#125; 模板继承parent.html 1234567891011121314&#123;% block header %&#125;This is parent top content!&#123;% endblock %&#125;&lt;section class=\"left\"&gt; &#123;% block left %&#125; &#123;% endblock %&#125;&lt;/section&gt;&lt;section class=\"right\"&gt; &#123;% block right %&#125; This is parent right content! &#123;% endblock %&#125;&lt;/section&gt; child.html 123456789&#123;% extends \"parent.html\" %&#125;&#123;% block left %&#125;This is child left content!&#123;% endblock %&#125;&#123;% block right %&#125;This is clild right content!&#123;% endblock %&#125; app.js 12345678910const Koa = require('koa');const app = new Koa();const nunjucks = require('nunjucks');nunjucks.configure('views', &#123; autoescape: true &#125;);app.use(ctx =&gt; &#123; ctx.body = nunjucks.render('child.html', &#123; name: 'nunjucks' &#125;)&#125;);app.listen(3000); 输出结果如下: 1234567891011121314This is father top content&lt;section class=&quot;left&quot;&gt;This is child left content!&lt;/section&gt;&lt;section class=&quot;right&quot;&gt;This is clild right content!&lt;/section&gt; 1可以看出，继承的使用方式为：使用 `&#123;% block &lt;blockname&gt; %&#125;&#123;% endblock %&#125;` 进行定义，使用 `&#123;% extends &quot;parent.html&quot; %&#125;` 进行继承，重新在子页面定义的内容将被重写 题外话 1当文中出现 &#123;% block &lt;blockname&gt; %&#125;&#123;% endblock %&#125; 的时候，hexo g 报错，是因为 hexo 模板引擎的原因;所以我将上面那句话放到了代码块中 参考资料Nunjucks官网文档","categories":[],"tags":[{"name":"koa","slug":"koa","permalink":"http://gaianote.github.io/tags/koa/"}]},{"title":"在windos下使用shell脚本","slug":"在windos下使用shell脚本","date":"2017-04-26T15:26:56.000Z","updated":"2017-05-16T02:52:15.498Z","comments":true,"path":"2017/04/26/在windos下使用shell脚本/","link":"","permalink":"http://gaianote.github.io/2017/04/26/在windos下使用shell脚本/","excerpt":"","text":"使用node切换命令行目录问题因为日常需要，打算使用nodejs写一个更改cmd命令行目录的小程序,保存一下日常使用的目录，方便进行目录切换，预想效果如下 1234&gt; E:\\Users\\gaian $ go project&gt; D:\\nodejs\\demos\\project&gt; D:\\nodejs\\demos\\project $ go blog&gt; E:\\Users\\gaian\\gaianote.github.io 本来以为很简单的几行代码就可以完成，后来发现这个需求居然无法实现，因为node的子进程无法更改父进程的工作目录 使用shell脚本进行功能实现于是打算使用shell进行功能实现，那么什么shell是用户和Linux操作系统之间的接口。Linux中有多种shell，其中缺省使用的是Bash。什么是bash呢? 简单来讲，Linux发行版支持各种各样的GUI（graphical user interfaces），但在某些情况下，Linux的命令行接口(bash)仍然是简单快速的。Bash和Linux Shell需要输入命令来完成任务，因而被称为命令行接口。 windows下具体步骤如下： 1.下载一个支持bash的cmd命令行工具，我一直在使用cmder，这款工具美观且功能强大，推荐大家尝试一下,在 cmder 中输入 bash ，就可以从 windows 的命令行模式更改为 bash 模式，非常方便 1234567# winE:\\Users\\gaianλ bash# bashgaian@DESKTOP-OTILKFV ~$ 其实我们可以通过设置 Cmder ，改为默认以 bash 模式启动 Cmder , 如果你不习惯 win 下的命令的话，可以进行以下设置： 以管理员身份运行 Cmder ，在 Cmder 中选择 Setting ，然后在 Startup -&gt; Tasks -&gt; {cmd::Cmder} 中输入如下启动方式，这样就可以通过鼠标右键菜单打开 Bash 了，并且是在当前文件夹打开，同时也避免了在 Vim 中方向键失灵的问题。 1cmd /k &quot;%ConEmuDir%\\..\\init.bat&quot; -new_console:p:n%USERPROFILE% &amp;bash 这样我们在打开 Cmder 后，便直接进入 Bash 模式 12gaian@DESKTOP-OTILKFV ~$ 当我们每次关闭 Cmder 时都会弹出提示框提示 Confirm closing console? ，只需要在 Setting -&gt; Main -&gt; Confirm -&gt; Close confirmations 中取消 When running process was detected 前面选中状态，就可以关闭提示框的弹出。 2.在user目录下，新建一个 .bashsrc 脚本，写入如下内容用 1234567go()&#123; if [ $1 = \"blog\" ]; then cd \"E:\\Users\\gaian\\gaianote.github.io\" elif [ $1 = \"post\" ]; then cd \"E:\\Users\\gaian\\gaianote.github.io\\source\\_posts\" fi&#125; 3.更新 .bashrc 使之立即生效 12$ cd ~$ source .bashrc 4.使用定义好的shell脚本 12345gaian@DESKTOP-OTILKFV ~$ go bloggaian@DESKTOP-OTILKFV ~/gaianote.github.io$ go postgaian@DESKTOP-OTILKFV ~/gaianote.github.io/source/_posts bash基本语法变量 bash变量不需要定义，使用时添加$表示变量 12STR=\"Hello World\"echo $STR 判断语句 123if [ \"foo\" = \"foo\" ]; then echo 'nice'fi 循环语句 123456n=1while [ $n -le 10 ]do echo $n let n++done break 语句可以让程序流程从当前循环体中完全跳出，而 continue 语句可以跳过当次循环的剩余部分并直接进入下一次循环 函数 bash 的函数不用传入参数，默认以 $1 $2 表示第一个变量，第二个变量… 123foo() &#123;echo $1&#125; 12$ foo HelloHello bash常用命令ls –List ls会列举出当前工作目录的内容（文件或文件夹），就跟你在GUI中打开一个文件夹去看里面的内容一样。 mkdir –Make Directory mkdir用于新建一个新目录 pwd –Print Working Directory pwd显示当前工作目录 cd –Change Directory 对于当前在终端运行的会中中，cd将给定的文件夹（或目录）设置成当前工作目录。 rmdir –Remove Directory rmdir删除给定的目录。 rm –Remove rm会删除给定的文件或文件夹，可以使用rm -r递归删除文件夹 cp –Copy cp命令对文件或文件夹进行复制，可以使用cp -r选项来递归复制文件夹。 mv –MoVe mv命令对文件或文件夹进行移动，如果文件或文件夹存在于当前工作目录，还可以对文件或文件夹进行重命名。 cat –concatenate and print files cat用于在标准输出（监控器或屏幕）上查看文件内容 tail –print TAIL (from last) &gt; tail默认在标准输出上显示给定文件的最后10行内容，可以使用tail -n N指定在标准输出上显示文件的最后N行内容。 less –print LESS less按页或按窗口打印文件内容。在查看包含大量文本数据的大文件时是非常有用和高效的。你可以使用Ctrl+F向前翻页，Ctrl+B向后翻页。 grep grep “”在给定的文件中搜寻指定的字符串。grep -i “”在搜寻时会忽略字符串的大小写，而grep -r “”则会在当前工作目录的文件中递归搜寻指定的字符串。 Find 这个命令会在给定位置搜寻与条件匹配的文件。你可以使用find -name的-name选项来进行区分大小写的搜寻，find -iname来进行不区分大小写的搜寻。find -iname tar tar命令能创建、查看和提取tar压缩文件。tar -cvf是创建对应压缩文件，tar -tvf来查看对应压缩文件，tar -xvf来提取对应压缩文件。 gzip gzip命令创建和提取gzip压缩文件，还可以用gzip -d来提取压缩文件。 unzip unzip对gzip文档进行解压。在解压之前，可以使用unzip -l命令查看文件内容。 help –help会在终端列出所有可用的命令,可以使用任何命令的-h或-help选项来查看该命令的具体用法。 whatis –What is this command whatis会用单行来描述给定的命令。 man –Manual man会为给定的命令显示一个手册页面。 exit exit用于结束当前的终端会话。 ping ping通过发送数据包ping远程主机(服务器)，常用与检测网络连接和服务器状态。 who –Who Is logged in who能列出当前登录的用户名。 su –Switch User su用于切换不同的用户。即使没有使用密码，超级用户也能切换到其它用户。 uname uname会显示出关于系统的重要信息，如内核名称、主机名、内核版本、处理机类型等等，使用uname -a可以查看所有信息。 free –Free memory free会显示出系统的空闲内存、已经占用内存、可利用的交换内存等信息，free -m将结果中的单位转换成KB，而free–g则转换成GB。 df –Disk space Freedf查看文件系统中磁盘的使用情况–硬盘已用和可用的存储空间以及其它存储设备。你可以使用df -h将结果以人类可读的方式显示。 ps –ProcesseS ps显示系统的运行进程。 Top –TOP processes top命令会默认按照CPU的占用情况，显示占用量较大的进程,可以使用top -u查看某个用户的CPU使用排名情况。 shutdown shutdown用于关闭计算机，而shutdown -r用于重启计算机。 start 以单独窗口运行程序，可以用来打开文件或文件夹,例如 start .打开当前文件夹 参考资料bash编程之if……else条件判断","categories":[],"tags":[]},{"title":"windows下的cmd命令行速查手册","slug":"windows下的cmd命令行速查手册","date":"2017-04-26T13:46:43.000Z","updated":"2017-05-16T02:52:15.454Z","comments":true,"path":"2017/04/26/windows下的cmd命令行速查手册/","link":"","permalink":"http://gaianote.github.io/2017/04/26/windows下的cmd命令行速查手册/","excerpt":"","text":"12345start # 启动单独的窗口以运行指定的程序或命令，可以用来打开文件夹rename # 重命名文件mkdir # 创建一个目录rm # 删除文件rmdir # 删除目录","categories":[],"tags":[]},{"title":"nodejs基础教程之fs模块","slug":"nodejs基础教程之fs模块","date":"2017-04-26T10:14:25.000Z","updated":"2017-05-16T02:52:15.362Z","comments":true,"path":"2017/04/26/nodejs基础教程之fs模块/","link":"","permalink":"http://gaianote.github.io/2017/04/26/nodejs基础教程之fs模块/","excerpt":"","text":"fs是filesystem的缩写，该模块提供的文件读写能力,几乎对所有操作提供异步和同步两种操作方式，供开发者选择 12const fs = require('fs')const fileName = __dirname + '/test.txt' 文件读写文件读取 fs.readFile(file[, options], callback) 异步读取 12345const fs = require('fs')fs.readFile(__dirname + '/test.txt', (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;); 1&lt;Buffer 68 65 6c 6c 6f 20 6e 6f 64 65 6a 73 ef bc 81&gt; fs.readFileSync(file[, options]) 同步读取 123let fileName = __dirname + '/test.txt'let data = fs.readFileSync(fileName, 'utf8');console.log('readFileSync_str:',data) 文件写入 writeFile方法用于异步写入文件。 1234fs.writeFile(fileName, 'Hello Node.js', 'utf8',(err) =&gt; &#123; if (err) throw err; console.log('It\\'s saved!');&#125;); writeFileSync方法用于同步写入文件。 1fs.writeFileSync(fileName, str, 'utf8'); 目录操作mkdir() &amp; mkdirSync()12345//mode default value 0o777fs.mkdir(path[, mode], callback)#//return undefinedfs.mkdirSync(path[, mode]) readdir() &amp; readdirSync()123456fs.readdir(path, function(err,files)&#123; if (err) throw err; console.log(files);&#125;)fs.readdirSync(path) files是一个包含了文件或目录名的数组 1[&apos;readdir.js&apos;,&apos;readFile.js&apos;,&apos;stat.js&apos;,&apos;test.txt&apos;,&apos;writeFile.js&apos; ] fs.stat我们可以通过fs.stat用于得到文件信息，判断文件是否存在，以及是文件还是目录 123fs.stat(fileName,(err,stats)=&gt;&#123; console.log(stats)&#125;) 如果文件不存在，输出undefined，如果文件存在，输出以下信息： 12345678910111213141516&#123; dev: 2114, ino: 48064969, mode: 33188, nlink: 1, uid: 85, gid: 100, rdev: 0, size: 527, blksize: 4096, blocks: 8, atime: Mon, 10 Oct 2011 23:24:11 GMT, mtime: Mon, 10 Oct 2011 23:24:11 GMT, ctime: Mon, 10 Oct 2011 23:24:11 GMT, birthtime: Mon, 10 Oct 2011 23:24:11 GMT&#125; stats的方法 1234567stats.isFile()stats.isDirectory()stats.isBlockDevice()stats.isCharacterDevice()stats.isSymbolicLink() (only valid with fs.lstat())stats.isFIFO()stats.isSocket() watchfile() &amp; unwatchfile()watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。 123456var fs = require('fs');fs.watchFile('message.text', (curr, prev) =&gt; &#123; console.log(`the current mtime is: $&#123;curr.mtime&#125;`); console.log(`the previous mtime was: $&#123;prev.mtime&#125;`);&#125;); unwatchfile方法用于解除对文件的监听。 createReadStream()createReadStream方法往往用于打开大型的文本文件，创建一个读取操作的数据流。所谓大型文本文件，指的是文本文件的体积很大，读取操作的缓存装不下，只能分成几次发送，每次发送会触发一个data事件，发送结束会触发end事件。 123456let input = fs.createReadStream(fileName);input.on('start',() =&gt; &#123;console.log('start')&#125;)input.on('data',(data) =&gt;&#123; console.log(data)&#125;)input.on('end', () =&gt; &#123;console.log('end')&#125;) createWriteStream方法创建一个写入数据流对象，该对象的write方法用于写入数据，end方法用于结束写入操作。 12345var out = fs.createWriteStream(fileName, &#123; encoding: 'utf8'&#125;);out.write(str);out.end(); createWriteStream方法和createReadStream方法配合，可以实现拷贝大型文件。 123456789101112function fileCopy(filename1, filename2, done) &#123; var input = fs.createReadStream(filename1); var output = fs.createWriteStream(filename2); input.on('data', (d) =&gt; &#123; output.write(d); &#125;); input.on('error', (err) =&gt; &#123; throw err; &#125;); input.on('end', () =&gt; &#123; output.end(); if (done) done(); &#125;);&#125; pipe()就像可以把两个水管串成一个更长的水管一样，两个流也可以串起来。一个Readable流和一个Writable流串起来后，所有的数据自动从Readable流进入Writable流，这种操作叫pipe。 在Node.js中，Readable流有一个 pipe() 方法，就是用来干这件事的。 让我们用 pipe() 把一个文件流和另一个文件流串起来，这样源文件的所有数据就自动写入到目标文件里了，所以，这实际上是一个复制文件的程序： 123456const fs = require('fs');const rs = fs.createReadStream('sample.txt');const ws = fs.createWriteStream('copied.txt');rs.pipe(ws); 默认情况下，当Readable流的数据读取完毕，end事件触发后，将自动关闭Writable流。如果我们不希望自动关闭Writable流，需要传入参数： 1readable.pipe(writable, &#123; end: false &#125;);","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"命令行程序开发教程","slug":"命令行程序开发教程","date":"2017-04-26T07:50:36.000Z","updated":"2017-05-16T02:52:15.485Z","comments":true,"path":"2017/04/26/命令行程序开发教程/","link":"","permalink":"http://gaianote.github.io/2017/04/26/命令行程序开发教程/","excerpt":"","text":"可执行脚本首先，使用 JavaScript 语言，写一个可执行脚本 hello（注意这里是hello不是hello.js） 12#!/usr/bin/env nodeconsole.log('hello world'); 然后，修改 hello 的权限 1$ chmod 755 hello 在当前目录下新建 package.json ，写入下面的内容 123456&#123; \"name\": \"hello\", \"bin\": &#123; \"hello\": \"hello\" &#125;&#125; 然后执行 npm link 命令。 1$ npm link 现在再执行 hello ，就不用输入路径了。 12$ hellohello world 命令行参数的原始写法命令行参数可以用系统变量 process.argv 获取。 下面是一个脚本 hello 12#!/usr/bin/env nodeconsole.log('hello ', process.argv[2]); 执行时，直接在脚本文件后面，加上参数即可。 12$ hello tomhello tom 上面代码中，实际上执行的是 node ./hello tom ，对应的 process.argv 是 [&#39;node&#39;, &#39;/path/to/hello&#39;, &#39;tom&#39;] 新建进程脚本可以通过 child_process 模块新建子进程，从而执行 Unix 系统命令。 12345678#!/usr/bin/env nodevar name = process.argv[2];var exec = require('child_process').exec;var child = exec('echo hello ' + name, function(err, stdout, stderr) &#123; if (err) throw err; console.log(stdout);&#125;); 用法如下。 12$ ./hello tomhello tom shelljs 模块shelljs 模块重新包装了 child_process，调用系统命令更加方便。它需要安装后使用。 1npm install --save shelljs 然后，改写脚本。 12345#!/usr/bin/env nodevar name = process.argv[2];var shell = require(\"shelljs\");shell.exec(\"echo hello \" + name); shelljs不赞成全局引入，那样会污染变量。 所以我们应该如此使用shell： 12345678910111213141516171819202122232425var shell = require('shelljs');if (!shell.which('git')) &#123; shell.echo('Sorry, this script requires git'); shell.exit(1);&#125;// Copy files to release dirshell.rm('-rf', 'out/Release');shell.cp('-R', 'stuff/', 'out/Release');// Replace macros in each .js fileshell.cd('lib');shell.ls('*.js').forEach(function (file) &#123; shell.sed('-i', 'BUILD_VERSION', 'v0.1.2', file); shell.sed('-i', /^.*REMOVE_THIS_LINE.*$/, '', file); shell.sed('-i', /.*REPLACE_LINE_WITH_MACRO.*\\n/, shell.cat('macro.js'), file);&#125;);shell.cd('..');// Run external tool synchronouslyif (shell.exec('git commit -am \"Auto-commit\"').code !== 0) &#123; shell.echo('Error: Git commit failed'); shell.exit(1);&#125; 命令参考yargs 模块shelljs 只解决了如何调用 shell 命令，而 yargs 模块能够解决如何处理命令行参数。它也需要安装。 1$ npm install --save yargs yargs 模块提供 argv 对象，用来读取命令行参数。请看改写后的 hello 。 1234#!/usr/bin/env nodevar argv = require('yargs').argv;console.log('hello ', argv.name); 使用时，下面两种用法都可以。 12$ hello --name=tomhello tom 12$ hello --name tomhello tom 也就是说，process.argv 的原始返回值如下。 1234$ node hello --name=tom[ 'node', '/path/to/myscript.js', '--name=tom' ] 参考链接Node.js 命令行程序开发教程","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"koa2学习系列教程8 mysql数据库","slug":"koa2学习系列教程8mysql数据库","date":"2017-04-25T12:31:36.000Z","updated":"2017-05-16T02:52:15.330Z","comments":true,"path":"2017/04/25/koa2学习系列教程8mysql数据库/","link":"","permalink":"http://gaianote.github.io/2017/04/25/koa2学习系列教程8mysql数据库/","excerpt":"","text":"在命令行使用mysql安装mysql对于mysql，我们除了在官网下载安装包以外，还可以使用XAMPP建站集成环境进行安装，安装完成后打开MySQL模块即可使用 添加环境变量找到mysql的bin文件夹，将其添加到环境变量路径，方便在cmd中使用mysql 添加方法：使用win自带的搜索功能，搜索环境变量，进入编辑环境变量后选择用户环境变量，选择PATH后编辑，选择新建，输入mysql的bin路径，比如我的是 E:\\xampp\\mysql\\bin 编辑PATH完成后，cmd重启生效 命令行的基本操作连接数据库 1$ mysql -h localhost -u root -p 要求输入password时，假如未设定，直接回车即可 显示用户名下的所有数据库 1$ show databases; 注意sql语句要求以’;’结尾，执行命令后，会输出形如下列的表格 123456789+--------------------+| Database |+--------------------+| information_schema || mynote || mysql || performance_schema || phpmyadmin |+--------------------+ 进入某个数据库 1$ use databasename 退出mysql 1$ exit; MYSQL 与 ORM如果直接使用mysql包提供的接口，我们编写的代码就比较底层，例如，查询代码： 12345connection.query('SELECT * FROM users WHERE id = ?', ['123'], function(err, rows) &#123; for (let row in rows) &#123; processRow(row); &#125;&#125;); 考虑到数据库表是一个二维表，包含多行多列，例如一个pets的表： 12345678mysql&gt; select * from pets;+----+--------+------------+| id | name | birth |+----+--------+------------+| 1 | Gaffey | 2007-07-07 || 2 | Odie | 2008-08-08 |+----+--------+------------+2 rows in set (0.00 sec) 每一行可以用一个JavaScript对象表示，例如第一行： 12345&#123; &quot;id&quot;: 1, &quot;name&quot;: &quot;Gaffey&quot;, &quot;birth&quot;: &quot;2007-07-07&quot;&#125; 这就是传说中的ORM技术：Object-Relational Mapping，把关系数据库的表结构映射到对象上 但是由谁来做这个转换呢？所以ORM框架应运而生。 ORM框架 Sequelize我们选择Node的ORM框架Sequelize来操作数据库。这样，我们读写的都是JavaScript对象，Sequelize帮我们把对象变成数据库中的行。 用Sequelize查询pets表，代码像这样： 12345678Pet.findAll() .then(function (pets) &#123; for (let pet in pets) &#123; console.log(`$&#123;pet.id&#125;: $&#123;pet.name&#125;`); &#125; &#125;).catch(function (err) &#123; // error &#125;); 因为Sequelize返回的对象是Promise，所以我们可以用then()和catch()分别异步响应成功和失败。 但是用then()和catch()仍然比较麻烦。有没有更简单的方法呢？ 可以用ES7的await来调用任何一个Promise对象，这样我们写出来的代码就变成了： 123(async () =&gt; &#123; var pets = await Pet.findAll();&#125;)(); 真的就是这么简单！ 考虑到koa的处理函数都是async函数，所以我们实际上将来在koa的async函数中直接写await访问数据库就可以了！ 这也是为什么我们选择Sequelize的原因：只要API返回Promise，就可以用await调用，写代码就非常简单！ 使用 Sequelize12npm install sequelize --savenpm install mysql --save 注意mysql是驱动，我们不直接使用，但是sequelize会用 配置config.js,他是一个简单的配置文件 123456789var config = &#123; database: 'test', // 使用哪个数据库 username: 'www', // 用户名 password: 'www', // 口令 host: 'localhost', // 主机名 port: 3306 // 端口号，MySQL默认3306&#125;;module.exports = config; 第一步，创建一个sequelize对象实例： 123456789101112const Sequelize = require('sequelize');const config = require('./config');var sequelize = new Sequelize(config.database, config.username, config.password, &#123; host: config.host, dialect: 'mysql', pool: &#123; max: 5, min: 0, idle: 30000 &#125;&#125;); 第二步，定义模型Pet，告诉Sequelize如何映射数据库表： 1234567891011121314var Pet = sequelize.define('pet', &#123; id: &#123; type: Sequelize.STRING(50), primaryKey: true &#125;, name: Sequelize.STRING(100), gender: Sequelize.BOOLEAN, birth: Sequelize.STRING(10), createdAt: Sequelize.BIGINT, updatedAt: Sequelize.BIGINT, version: Sequelize.BIGINT&#125;, &#123; timestamps: false &#125;); 用sequelize.define()定义Model时，传入名称pet，默认的表名就是pets。第二个参数指定列名和数据类型，如果是主键，需要更详细地指定。第三个参数是额外的配置，我们传入{ timestamps: false }是为了关闭Sequelize的自动添加timestamp的功能。所有的ORM框架都有一种很不好的风气，总是自作聪明地加上所谓“自动化”的功能，但是会让人感到完全摸不着头脑。 插入数据123456789101112(async () =&gt; &#123; var dog = await Pet.create(&#123; id: 'd-' + now, name: 'Odie', gender: false, birth: '2008-08-08', createdAt: now, updatedAt: now, version: 0 &#125;); console.log('created: ' + JSON.stringify(dog));&#125;)(); 显然await代码更胜一筹。 查询数据1234567891011(async () =&gt; &#123; var pets = await Pet.findAll(&#123; where: &#123; name: 'Gaffey' &#125; &#125;); console.log(`find $&#123;pets.length&#125; pets:`); for (let p of pets) &#123; console.log(JSON.stringify(p)); &#125;&#125;)(); 更新数据，可以对查询到的实例调用save()方法：1234567(async () =&gt; &#123; var p = await queryFromSomewhere(); p.gender = true; p.updatedAt = Date.now(); p.version ++; await p.save();&#125;)(); 删除数据，可以对查询到的实例调用destroy()方法：1234(async () =&gt; &#123; var p = await queryFromSomewhere(); await p.destroy();&#125;)(); Model为了避免格式上的混乱，我们需要一个统一的模型，强迫所有Model都遵守同一个规范，这样不但实现简单，而且容易统一风格。 我们首先要定义的就是Model存放的文件夹必须在models内，并且以Model名字命名，例如：Pet.js，User.js等等。 其次，每个Model必须遵守一套规范： 统一主键，名称必须是id，类型必须是STRING(50)； 主键可以自己指定，也可以由框架自动生成（如果为null或undefined）； 所有字段默认为NOT NULL，除非显式指定； 统一timestamp机制，每个Model必须有createdAt、updatedAt和version，分别记录创建时间、修改时间和版本号。其中，createdAt和updatedAt以BIGINT存储时间戳，最大的好处是无需处理时区，排序方便。version每次修改时自增。 数据库配置接下来，我们把简单的config.js拆成3个配置文件： config-default.js：存储默认的配置; config-override.js：存储特定的配置; config-test.js：存储用于测试的配置; 例如，默认的config-default.js可以配置如下： 1234567891011var config = &#123; dialect: 'mysql', database: 'nodejs', username: 'www', password: 'www', host: 'localhost', port: 3306&#125;;module.exports = config; 而config-override.js可应用实际配置： 12345678var config = &#123; database: 'production', username: 'www', password: 'secret-password', host: '192.168.1.199'&#125;;module.exports = config; config-test.js可应用测试环境的配置： 1234var config = &#123; database: 'test'&#125;;module.exports = config; 读取配置的时候，我们用config.js实现不同环境读取不同的配置文件： 1234567891011121314151617181920212223242526const defaultConfig = './config-default.js';// 可设定为绝对路径，如 /opt/product/config-override.jsconst overrideConfig = './config-override.js';const testConfig = './config-test.js';const fs = require('fs');var config = null;if (process.env.NODE_ENV === 'test') &#123; console.log(`Load $&#123;testConfig&#125;...`); config = require(testConfig);&#125; else &#123; console.log(`Load $&#123;defaultConfig&#125;...`); config = require(defaultConfig); try &#123; if (fs.statSync(overrideConfig).isFile()) &#123; console.log(`Load $&#123;overrideConfig&#125;...`); config = Object.assign(config, require(overrideConfig)); &#125; &#125; catch (err) &#123; console.log(`Cannot load $&#123;overrideConfig&#125;.`); &#125;&#125;module.exports = config; 具体的规则是： 先读取config-default.js；如果不是测试环境，就读取config-override.js，如果文件不存在，就忽略。如果是测试环境，就读取config-test.js。这样做的好处是，开发环境下，团队统一使用默认的配置，并且无需config-override.js。部署到服务器时，由运维团队配置好config-override.js，以覆盖config-override.js的默认设置。测试环境下，本地和CI服务器统一使用config-test.js，测试数据库可以反复清空，不会影响开发。 配置文件表面上写起来很容易，但是，既要保证开发效率，又要避免服务器配置文件泄漏，还要能方便地执行测试，就需要一开始搭建出好的结构，才能提升工程能力。 使用Model要使用Model，就需要引入对应的Model文件，例如：User.js。一旦Model多了起来，如何引用也是一件麻烦事。 自动化永远比手工做效率高，而且更可靠。我们写一个model.js，自动扫描并导入所有Model： 1234567891011121314151617181920const fs = require('fs');const db = require('./db');let files = fs.readdirSync(__dirname + '/models');let js_files = files.filter((f)=&gt;&#123; return f.endsWith('.js');&#125;, files);module.exports = &#123;&#125;;for (let f of js_files) &#123; console.log(`import model from file $&#123;f&#125;...`); let name = f.substring(0, f.length - 3); module.exports[name] = require(__dirname + '/models/' + f);&#125;module.exports.sync = () =&gt; &#123; return db.sync();&#125;; 这样，需要用的时候，写起来就像这样： 1234567const model = require('./model');let Pet = model.Pet, User = model.User;var pet = await Pet.create(&#123; ... &#125;); 工程结构最终，我们创建的工程model-sequelize结构如下： 12345678910111213141516model-sequelize/||-.vscode| |-launch.json # VSCode 配置文件|-models # 存放所有Model| |-Pet.js # Pet| |-User.js # User|-config.js # 配置文件入口|-config-default.js # 默认配置文件|-config-test.js # 测试配置文件|-db.js # 如何定义Model|-model.js # 如何导入Model|-init-db.js # 初始化数据库|-app.js # 业务代码|-package.json # 项目描述文件|-node_modules/ # npm安装的所有依赖包 注意到我们其实不需要创建表的SQL，因为Sequelize提供了一个sync()方法，可以自动创建数据库。这个功能在开发和生产环境中没有什么用，但是在测试环境中非常有用。测试时，我们可以用sync()方法自动创建出表结构，而不是自己维护SQL脚本。这样，可以随时修改Model的定义，并立刻运行测试。开发环境下，首次使用sync()也可以自动创建出表结构，避免了手动运行SQL的问题。 init-db.js的代码非常简单，作用是创建Pets和User表，只需要执行一次即可。 12345678910const model = require('./model.js');model.sync().then(()=&gt;&#123; console.log('sync done'); process.exit(0);&#125;).catch((e)=&gt;&#123; console.log('failed with: '+e); process.exit(0);&#125;);console.log('init db ok.'); 参考文档 廖雪峰的官方网站Sequelize官方文档","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"},{"name":"mysql","slug":"mysql","permalink":"http://gaianote.github.io/tags/mysql/"}]},{"title":"koa2学习系列教程4 context应用上下文","slug":"koa2学习系列教程4_context上下文","date":"2017-04-25T06:46:55.000Z","updated":"2017-05-16T02:52:15.296Z","comments":true,"path":"2017/04/25/koa2学习系列教程4_context上下文/","link":"","permalink":"http://gaianote.github.io/2017/04/25/koa2学习系列教程4_context上下文/","excerpt":"","text":"context对象的全局属性 request：指向Request对象 response：指向Response对象 req：指向Node的request对象 res：指向Node的response对象 app：指向App对象 state：用于在中间件传递信息。 state 对象1cyx.state.user = await User.find(id); 上面代码中，user属性存放在this.state对象上面，可以被另一个中间件读取。 Request与Response 对象我们可以使用ctx.request，ctx.response获取请求头与响应头 1234app.use( async(ctx) =&gt; &#123; ctx.request; // is a koa Request ctx.response; // is a koa Response&#125;); 尝试输出以上信息，输出结果如下 123456789101112131415161718# ctx.request&#123; method: &apos;GET&apos;, url: &apos;/&apos;, header: &#123; host: &apos;127.0.0.1:3000&apos;, connection: &apos;keep-alive&apos;, &apos;upgrade-insecure-requests&apos;: &apos;1&apos;, &apos;user-agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36&apos;, accept: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;accept-encoding&apos;: &apos;gzip, deflate, sdch, br&apos;, &apos;accept-language&apos;: &apos;zh-CN,zh;q=0.8&apos; &#125; &#125;# ctx.response&#123; status: 200, message: &apos;OK&apos;, header: &#123; &apos;content-type&apos;: &apos;text/plain; charset=utf-8&apos;, &apos;content-length&apos;: &apos;9&apos; &#125;, body: &apos;Hello Koa&apos; &#125; Koa 的上下文封装了 request 与 response 对象至一个对象中，并提供了一些帮助开发者编写业务逻辑的方法。 Request 对象 ctx.header ctx.method ctx.method= ctx.url ctx.url= ctx.path ctx.path= ctx.query ctx.query= ctx.querystring ctx.querystring= ctx.length ctx.host ctx.fresh ctx.stale ctx.socket ctx.protocol ctx.secure ctx.ip ctx.ips ctx.subdomains ctx.is() ctx.accepts() ctx.acceptsEncodings() ctx.acceptsCharsets() ctx.acceptsLanguages() ctx.get() Response 对象 ctx.body ctx.body= ctx.status ctx.status= ctx.length= ctx.type ctx.type= ctx.headerSent ctx.redirect() ctx.attachment() ctx.set() ctx.remove() ctx.lastModified= ctx.etag= context对象的全局方法 throw()：抛出错误，直接决定了HTTP回应的状态码。 assert()：如果一个表达式为false，则抛出一个错误。 ctx.throw()ctx.throw(msg, [status]) 抛出常规错误的辅助方法，默认 status 为 500。 以下几种写法都有效： 1234ctx.throw(403)ctx.throw('name required', 400)ctx.throw(400, 'name required')ctx.throw('something exploded') 实际上，ctx.throw(&#39;name required&#39;, 400) 是此代码片段的简写方法： 123var err = new Error('name required');err.status = 400;throw err; 需要注意的是，ctx.throw 创建的错误，均为用户级别错误（标记为err.expose），会被返回到客户端。 ctx.assert()12345// 格式ctx.assert(value, [msg], [status], [properties])// 例子this.assert(this.user, 401, 'User not found. Please login!');","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"},{"name":"koa","slug":"koa","permalink":"http://gaianote.github.io/tags/koa/"}]},{"title":"koa2学习系列教程3 路由与koa-router","slug":"koa2学习系列教程3_路由与koa-router","date":"2017-04-24T11:45:05.000Z","updated":"2017-05-16T02:52:15.289Z","comments":true,"path":"2017/04/24/koa2学习系列教程3_路由与koa-router/","link":"","permalink":"http://gaianote.github.io/2017/04/24/koa2学习系列教程3_路由与koa-router/","excerpt":"","text":"路由的基本用法可以通过this.path属性，判断用户请求的路径，从而起到路由作用。 123456789101112131415app.use(async (ctx,next)=&gt;&#123; if (ctx.path === '/') &#123; ctx.body = 'we are at home!'; &#125; else &#123; await next; &#125;&#125;)app.use(async (ctx,next)=&gt;&#123; if (ctx.path === '/404') &#123; ctx.body = 'page not found'; &#125; else &#123; await next; &#125;&#125;) 上面代码中，每一个中间件负责一个路径，如果路径不符合，就传递给下一个中间件。 复杂的路由需要安装koa-router插件。 koa-router由于api更新等问题，使用时如果未达到预想效果，可以到npm查看官方文档 koa-router 基本的使用123456789101112131415var Koa = require('koa');var Router = require('koa-router');var app = new Koa();var router = new Router();router.get('/', async (ctx, next) =&gt;&#123; ctx.body = 'we are at home!';&#125;);app .use(router.routes()) .use(router.allowedMethods());app.listen(3000) 路径匹配的时候，不会把查询字符串考虑在内。比如，/index?param=xyz 匹配路径为 /index HTTP动词方法Koa-router实例提供一系列动词方法，即一种HTTP动词对应一种方法。 12345678router .get('/', async (ctx, next) =&gt; &#123; ctx.body = 'Hello World!'; &#125;) .post('/users', async (ctx, next) =&gt; &#123;...&#125;) .put('/users/:id', async (ctx, next) =&gt; &#123;...&#125;) .del('/users/:id', async (ctx, next) =&gt; &#123;...&#125;) .all('/users/:id', async (ctx, next) =&gt; &#123;...&#125;) router.all()用于表示上述所有的动词方法 123router.get('/', async (ctx,next) =&gt; &#123; ctx.body = 'Hello World!';&#125;); 上面代码中，router.get方法的第一个参数是根路径，第二个参数是对应的函数方法。 路由参数我们可以通过ctx.params得到URL参数 1234router.get('/:category/:title', function (ctx, next) &#123; console.log(ctx.params); // =&gt; &#123; category: 'programming', title: 'how-to-node' &#125;&#125;); 支持多个中间件12345678910111213router.get( '/users/:id', function (ctx, next) &#123; return User.findOne(ctx.params.id).then(function(user) &#123; ctx.user = user; return next(); &#125;); &#125;, function (ctx) &#123; console.log(ctx.user); // =&gt; &#123; id: 17, name: \"Alex\" &#125; &#125;); 路由前缀123456var router = new Router(&#123; prefix: '/users'&#125;);router.get('/', ...); // responds to \"/users\"router.get('/:id', ...); // responds to \"/users/:id\" 重构每个 url 对应一个规则，如果全部放在 app.js 中会造成代码紊乱且难以理解。因此重构整个项目，项目文件结构如下： 12345|-controller # 用于存放路由规则| |-index.js # 首页路由规则| |-user.js # user路由规则|-controller.js # 自动导入controller下的所有路由规则|-app.js # 入口文件，用于启动koa服务器 index.js 内容如下 1234567const homepage = async (ctx, next) =&gt;&#123; ctx.body = 'we are at home!';&#125;module.exports = &#123; 'GET /': homepage&#125;; 当 require(‘controller/index’) 时，会得到一个包含了规则的对象 {&#39;GET /&#39;: homepage} 其中，GET 表示 GET 方法 / 表示解析路径，homepage 是针对这个路径所做的操作。解析规则由 controller.js 的 add_rule 方法实现 controller.js 内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142const fs = require('fs')const Router = require('koa-router');const router = new Router();// 解析规则 &#123;'GET /': homepage&#125;function add_rule(router, rule) &#123; for (let key in rule) &#123; // key = 'GET /' rule = &#123;'GET /': homepage&#125; if (key.startsWith('GET ')) &#123; let path = key.substring(4); router.get(path, rule[key]); console.log(`register URL mapping: GET $&#123;path&#125;`); &#125; else if (key.startsWith('POST ')) &#123; let path = key.substring(5); router.post(path, rule[key]); console.log(`register URL mapping: POST $&#123;path&#125;`); &#125; else &#123; console.log(`invalid URL: $&#123;key&#125;`); &#125; &#125;&#125;//自动导入controller文件夹下所有的路由规则function add_rules(router) &#123; // 得到 /controller 所有以js结尾的文件 let files = fs.readdirSync(__dirname + '/controller'); let js_files = files.filter((f) =&gt; &#123; return f.endsWith('.js'); &#125;); // 添加规则 for (let f of js_files) &#123; console.log(`process controller: $&#123;f&#125;...`); let rule = require(__dirname + '/controller/' + f); add_rule(router, rule); &#125;&#125;module.exports = function () &#123; add_rules(router); return router.routes();&#125;; app.js 内容如下: 12345678const Koa = require('koa');const app = new Koa();const controller = require('./controller');//app.use(router.routes())app.use(controller())app.listen(3000) koa-router源码解读廖雪峰的官方网站","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"},{"name":"koa","slug":"koa","permalink":"http://gaianote.github.io/tags/koa/"}]},{"title":"koa2学习系列教程1 Hello Koa","slug":"koa2学习系列教程1_Hello_Koa","date":"2017-04-24T07:09:55.000Z","updated":"2017-05-16T02:52:15.276Z","comments":true,"path":"2017/04/24/koa2学习系列教程1_Hello_Koa/","link":"","permalink":"http://gaianote.github.io/2017/04/24/koa2学习系列教程1_Hello_Koa/","excerpt":"","text":"安装koa依赖于node v7.6.0或者更高的node版本，如果版本未达到要求，请升级 1$ npm install koa Hello koa123456789const Koa = require('koa');const app = new Koa();// responseapp.use(ctx =&gt; &#123; ctx.body = 'Hello Koa';&#125;);app.listen(3000); ctx.body = ‘Hello World’这行代码表示设置response.body的值为’Hello World, 一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组同步或异步函数组成。 这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。 变量app就是一个Koa应用。它监听3000端口，返回一个内容为Hello Koa的网页 app.use方法用于向middleware数组添加相应函数。 listen方法指定监听端口，并启动当前应用。 异步编程终极解决方案 asyncasync是js异步执行的最佳方案，await无法单独出现，总是需要与async配合使用; async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 12345678async function foo ()=&gt;&#123; console.log('foo start') await sub() console.log('foo end')&#125;async function sub ()=&gt;&#123; console.log('sub')&#125; async表示这个函数是异步的 await sub() 表示等待 sub() 执行完毕,并返回结果后，继续向下执行 输出结果如下： 123foo startsubfoo end 中间件 (async需要node v7.6+)koa是一个可以使用两种函数作为中间件的中间件框架 async function common function 123456789101112131415//异步的app.use(async (ctx, next) =&gt; &#123; console.log('first middleware start') await next(); await sub(); console.log('first middleware end')&#125;);//同步的app.use(()=&gt;&#123; console.log('second middleware')&#125;)const sub = ()=&gt;&#123; console.log('sub')&#125; 输出结果如下： 1234first middleware startsecond middlewaresubfirst middleware end app.use的参数就是中间件，可以看出，通过await next()可以调用下一个中间件，通过await func()可以调用其他函数 参考文档koa 中文文档koa实战","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"},{"name":"koa","slug":"koa","permalink":"http://gaianote.github.io/tags/koa/"}]},{"title":"koa2学习系列教程2 中间件","slug":"koa2学习系列教程2_中间件","date":"2017-04-24T07:09:55.000Z","updated":"2017-05-16T02:52:15.279Z","comments":true,"path":"2017/04/24/koa2学习系列教程2_中间件/","link":"","permalink":"http://gaianote.github.io/2017/04/24/koa2学习系列教程2_中间件/","excerpt":"","text":"","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"},{"name":"koa","slug":"koa","permalink":"http://gaianote.github.io/tags/koa/"}]},{"title":"Node.js框架之express与koa对比分析","slug":"Node-js框架之express与koa对比分析","date":"2017-04-24T06:40:20.000Z","updated":"2017-05-16T02:52:15.231Z","comments":true,"path":"2017/04/24/Node-js框架之express与koa对比分析/","link":"","permalink":"http://gaianote.github.io/2017/04/24/Node-js框架之express与koa对比分析/","excerpt":"","text":"学习了Node.js框架之express与koa对比分析这篇文章，个人对于express以及koa有了初步的了解，综合考虑，决定使用koa进行后台开发。以下为文章正文。 提到Node.js开发，不得不提目前炙手可热的2大框架express和koa。Express诞生已有时日，是一个简洁而灵活的web开发框架，使用简单而功能强大。Koa相对更为年轻，是Express框架原班人马基于ES6新特性重新开发的敏捷开发框架，现在可谓风头正劲，大有赶超Express之势。 Express和koa都是服务端的开发框架，服务端开发的重点是对HTTP Request和HTTP Response两个对象的封装和处理，应用的生命周期维护以及视图的处理等。 以下将主要通过这些方面，对两者进行一个对比介绍，看看到底有什么区别。 Express主要基于Connect中间件框架，功能丰富，随取随用，并且框架自身封装了大量便利的功能，比如路由、视图处理等等。而koa主要基于co中间件框架，框架自身并没集成太多功能，大部分功能需要用户自行require中间件去解决，但是由于其基于ES6 generator特性的中间件机制，解决了长期诟病的“callback hell”和麻烦的错误处理的问题，大受开发者欢迎。 Express和koa初印象先来一个Hello World，各自认识一下吧 12345678910111213141516171819202122232425//Expressvar express = require('express')var app = express() //创建一个APP实例//建一个项目根目录的get请求路由，回调方法中直接输出字符串Hello World!app.get('/', function (req, res) &#123; res.send('Hello World!')&#125;);//监听端口，启动服务app.listen(3000);//Koavar koa = require('koa');var route = require('koa-route'); //koa默认没有集成route功能，引入中间件var app = koa(); //创建一个APP实例//建一个项目根目录的get请求路由，回调方法中直接输出字符串Hello World!，就是挂载一个中间件app.use(route.get('/', function *()&#123; this.body = 'Hello World';&#125;));//监听端口，启动服务app.listen(3000); 可以看出来，两者创建一个基础的Web服务都非常简单，可以说几行代码就解决了问题。两者的写法也基本相同，最大的区别是路由处理Express是自身集成的，而koa需要引入中间件。以下是Koa官方文档对于两者特性的一个对比： 重要功能对比介绍 Feature Koa Express ConnectMiddleware KernelRoutingTemplatingSending FilesJSONP 通过后续的比较，大家其实可以看出，虽然koa看上去比express少集成了很多功能，但是使用起来其实基本一致，因为中间件非常丰富全面，需要什么require进来就行了（不一定要像express那样先帮你require好），使用起来反而更加灵活。 应用生命周期和上下文我们在项目过程中，经常需要用到在整个应用生命周期中共享的配置和数据对象，比如服务URL、是否启用某个功能特性、接口配置、当前登录用户数据等等。属于比较基础的功能，两者都非常方便，koa的application context感觉使用起来更方便一点。 123456789101112131415161718192021222324252627282930//Express//共享配置，express提供了很多便利的方法app.set('enableCache', true)app.get('enableCache')//trueapp.disable('cache')app.disabled('cache')//trueapp.enable('cache')app.enabled('cache')//true//应用共享数据：app.localsapp.locals.user = &#123;name:\"Samoay\", id:1234&#125;;//Koa//配置，直接使用koa context即可app.enableCache = true;app.use(function *(next)&#123; console.log(this.app.enableCache); //true this.app.enableCache = false; //just use this this.staticPath = 'static'; yield *next;&#125;);//应用共享数据：ctx.statethis.state.user = &#123;name:\"Samoay\", id:1234&#125;; 请求 HTTP Request服务器端需要进行什么处理，怎么处理以及处理的参数都依赖客户端发送的请求，两个框架都封装了HTTP Request对象，便于对这一部分进行处理。以下主要举例说明下对请求参数的处理，其它例如头信息、Cookie等请参考官方文档。两者除了写法上稍有区别，没太大区别。GET参数都可以直接通过Request对象获取，POST参数都需要引入中间件先parse，再取值。 12345678910111213141516171819202122232425262728293031323334353637383940414243// Express// 获取QueryString参数// GET /shoes?order=desc&amp;shoe[color]=bluereq.query.order// =&gt; \"desc\"req.query.shoe.color// =&gt; \"blue\"// 通过路由获取Restful风格的URL参数app.get('/user/:id?', function userIdHandler(req, res) &#123; console.log(req.params.id); res.send('GET');&#125;)//获取POST数据:需要body-parser中间件var bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123; extended: true &#125;));app.post('/', function (req, res) &#123; console.log(req.body); res.json(req.body);&#125;)// 获取QueryString参数// GET /?action=delete&amp;id=1234this.request.query// =&gt; &#123; action: 'delete', id: '1234' &#125;// 通过路由获取Restful风格的URL参数var route = require('koa-route');app.use(route.get('/post/:id', function *(id)&#123; console.log(id); // =&gt; 1234&#125;));// 获取POST数据:需要co-body中间件// Content-Type: application/x-www-form-urlencoded// title=Test&amp;content=This+is+a+test+postvar parse = require('co-body');app.use(route.post('/post/new', function *()&#123; var post = yield parse(this.request);//this console.log(post); // =&gt; &#123; title: 'Test', content: 'This is a test post' &#125;&#125;)); 路由 Route收到客户端的请求，服务需要通过识别请求的方法（HTTP Method: GET, POST, PUT…）和请求的具体路径(path)来进行不同的处理。这部分功能就是路由（Route）需要做的事情，说白了就是请求的分发，分发到不同的回调方法去处理。 12345678910111213141516171819202122232425262728293031323334353637383940// Express// app.all表示对所有的路径和请求方式都要经过这些回调方法的处理，可以逗号方式传入多个app.all('*', authentication, loadUser);// 也可以多次调用app.all('*', requireAuthentication)app.all('*', loadUser);// 也可以针对某具体路径下面的所有请求app.all('/api/*', requireAuthentication);// app.get GET方式的请求app.get('/user/:id', function(req, res) &#123; res.send('user ' + req.params.id);&#125;);// app.post POST方式的请求app.post('/user/create', function(req, res) &#123; res.send('create new user');&#125;);这里需要说明2个问题，首先是 app.get ，在应用生命周期中也有一个 app.get 方法，用于获取项目配置。Express内部就是公用的一个方法，如果传入的只有1个参数就获取配置，2个参数就作为路由处理。其次是 app.use('*', cb) 与 app.all('*', cb) 的区别，前者是中间件方式，调用是有顺序的，不一定会执行到；后者是路由方式，肯定会执行到。// Koa// 和Express不同，koa需要先引入route中间件var route = require('koa-route');//引入中间件之后支持的写法差不多，只是路径传入route，然后把route作为中间件挂载到appapp.use(route.get('/', list));app.use(route.get('/post/new', add));app.use(route.get('/post/:id', show));app.use(route.post('/post', create));//链式写法var router = require('koa-router')();router.get('/', list) .get('/post/new', add) .get('/post/:id', show) .post('/post', create);app.use(router.routes()) .use(router.allowedMethods()); 视图 ViewsExpress框架自身集成了视图功能，提供了consolidate.js功能，可以是有几乎所有Javascript模板引擎，并提供了视图设置的便利方法。Koa需要引入co-views中间件，co-views也是基于consolidate.js，支持能力一样强大。 12345678910111213141516171819202122232425262728293031323334353637// Express// 这只模板路径和默认的模板后缀app.set('views', __dirname + '/tpls');app.set('view engine', 'html');//默认，express根据template的后缀自动选择模板//引擎渲染，支持jade和ejs。如果不使用默认扩展名app.engine(ext, callback)app.engine('html', require('ejs').renderFile);//如果模板引擎不支持(path, options, callback)var engines = require('consolidate');app.engine('html', engines.handlebars);app.engine('tpl', engines.underscore);app.get('list', function(res, req)&#123; res.render('list', &#123;data&#125;);&#125;);//Koa//需要引入co-views中间件var views = require('co-views');var render = views('tpls', &#123; map: &#123; html: 'swig' &#125;,//html后缀使用引擎 default: \"jade\"//render不提供后缀名时&#125;);var userInfo = &#123; name: 'tobi', species: 'ferret'&#125;;var html;html = render('user', &#123; user: userInfo &#125;);html = render('user.jade', &#123; user: userInfo &#125;);html = render('user.ejs', &#123; user: userInfo &#125;); 返回 HTTP Response获取完请求参数、处理好了具体的请求、视图也准备就绪，下面就该返回给客户端了，那就是HTTP Response对象了。这部分也属于框架的基础部分，各种都做了封装实现，显著的区别是koa直接将输出绑定到了ctx.body属性上，另外输出JSON或JSONP需要引入中间件。 12345678910111213141516171819202122232425262728293031323334353637383940// Express//输出普通的htmlres.render('tplName', &#123;data&#125;);//输出JSONres.jsonp(&#123; user: 'Samoay' &#125;);// =&gt; &#123; \"user\": \"Samoay\" &#125;//输出JSONP ?callback=foores.jsonp(&#123; user: 'Samoay' &#125;);// =&gt; foo(&#123; \"user\": \"Samoay\" &#125;);//res.send([body]);res.send(new Buffer('whoop'));res.send(&#123; some: 'json' &#125;);res.send('&lt;p&gt;some html&lt;/p&gt;');//设定HTTP Status状态码res.status(200);//koa直接set ctx的status和bodyapp.use(route.get('/post/update/:id', function *(id)&#123; this.status = 404; this.body = 'Page Not Found';&#125;));var views = require('co-views');var render = views('tpls', &#123; default: \"jade\"//render不提供后缀名时&#125;);app.use(route.get('/post/:id', function *(id)&#123; var post = getPost(id); this.status = 200;//by default, optional this.body = yield render('user', post);&#125;));//JSONvar json = require('koa-json');app.use(route.get('/post/:id', function *(id)&#123; this.body = &#123;id:1234, title:\"Test post\", content:\"...\"&#125;;&#125;)); 中间件 Middleware对比了主要的几个框架功能方面的使用，其实区别最大，使用方式最不同的地方是在中间件的处理上。Express由于是在ES6特性之前的，中间件的基础原理还是callback方式的；而koa得益于generator特性和co框架（co会把所有generator的返回封装成为Promise对象），使得中间件的编写更加优雅。 123456789101112131415161718192021222324252627282930// req 用于获取请求信息， ServerRequest 的实例// res 用于响应处理结果， ServerResponse 的实例// next() 函数用于将当前控制权转交给下一步处理，// 如果给 next() 传递一个参数时，表示出错信息var x = function (req, res, next) &#123; // 对req和res进行必要的处理 // 进入下一个中间件 return next(); // 传递错误信息到下一个中间件 return next(err); // 直接输出，不再进入后面的中间件 return res.send('show page');&#125;;// koa 一切都在ctx对象上+generatorapp.use(function *()&#123; this; // is the Context this.request; // is a koa Request this.response; // is a koa Response this.req;// is node js request this.res;// is node js response //不再进入后面的中间件, 回溯upstream return;&#125;); 本文转载自：Node.js框架之express与koa对比分析","categories":[],"tags":[{"name":"nodejs 开发框架 服务器","slug":"nodejs-开发框架-服务器","permalink":"http://gaianote.github.io/tags/nodejs-开发框架-服务器/"}]},{"title":"python基础教程之操作文件和目录","slug":"python基础教程之操作文件和目录","date":"2017-04-24T02:23:13.000Z","updated":"2017-05-16T02:52:15.405Z","comments":true,"path":"2017/04/24/python基础教程之操作文件和目录/","link":"","permalink":"http://gaianote.github.io/2017/04/24/python基础教程之操作文件和目录/","excerpt":"","text":"环境变量在操作系统中定义的环境变量，全部保存在os.environ这个变量中 12os.environos.environ.get('PATH') 操作文件和目录查看当前目录的绝对路径 1dir = os.path.abspath('.') 在当前目录操作一个新目录newdir,首先需要得到这个目录的绝对路径 1newdir = os.path.join(dir, 'newdir') 路径操作不应使用字符串拼接，而应该使用os.path模块;因为不同操作系统的路径分隔符是不同的 创建新目录 1os.mkdir(newdir) 删除目录 1os.rmdir(newdir) 得到当前目录下所有的文件夹 1[x for x in os.listdir('.') if os.path.isdir(x)] 得到当前目录下所有的.py文件 1[x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"requests速查手册","slug":"difflib","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.259Z","comments":true,"path":"2017/04/23/difflib/","link":"","permalink":"http://gaianote.github.io/2017/04/23/difflib/","excerpt":"","text":"12345import difflibstr1 = '拥有一拳就能打倒任何怪人设定的斗篷光头男的名字是'str2 = '拥有quit拳q^it就能打倒任何怪人设定的斗篷光头男的名字是'result = difflib.SequenceMatcher(None, str1, str2).ratio()print(result)","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"requests速查手册","slug":"requests速查手册","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-20T11:42:12.650Z","comments":true,"path":"2017/04/23/requests速查手册/","link":"","permalink":"http://gaianote.github.io/2017/04/23/requests速查手册/","excerpt":"","text":"get请求网址与传递参数 12payload = &#123;'key1': 'value1', 'key2': 'value2'&#125;r = requests.get(url, params=payload) 定制请求头 12headers = &#123;'user-agent': 'my-app/0.0.1'&#125;r = requests.get(url, headers=headers) 超时 1r = requests.get(url, timeout=0.001) 短链接 1r = requests.get(url,headers=&#123;'Connection':'close'&#125;) post发送表单数据 12data = &#123;'key':'value'&#125;r = requests.post(url, data=data) 发送json数据 123# requests会自动序列化datadata = &#123;'key':'value'&#125;r = requests.post(url, json=data) 处理返回结果12# 得到jsonr.json() 代理ip12345678import requestsproxies = &#123; 'http': 'http://10.10.1.10:3128', 'https': 'http://10.10.1.10:1080',&#125;requests.get('http://example.org', proxies=proxies) 编码与解码问题我们可以通过 r.encoding 查看requests抓取文件的编码 12r = requests.get(url)print (r.encoding) 如果 Requests 检测不到正确的编码，那么你告诉它正确的是什么： 12response.encoding = 'gbk'print (response.text) 字符串在Python内部的表示是 unicode 编码，因此，在做编码转换时，通常需要以 unicode 作为中间编码，即先将其他编码的字符串解码 decode 成 unicode ，再从 unicode 编码 encode 成另一种编码。 decode 的作用是将其他编码的字符串转换成unicode编码，如 str1.decode(&#39;gb2312&#39;)，表示将 gb2312 编码的字符串 str1 转换成 unicode 编码。 encode 的作用是将 unicode 编码转换成其他编码的字符串，如 str2.encode(&#39;gb2312&#39;)，表示将 unicode 编码的字符串 str2 转换成 gb2312编码。 如果一个字符串已经是 unicode 了，再进行解码则将出错，因此通常要对其编码方式是否为 unicode 进行判断，用非 unicode 编码形式的str来 encode 会报错","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"},{"name":"requests","slug":"requests","permalink":"http://gaianote.github.io/tags/requests/"},{"name":"爬虫","slug":"爬虫","permalink":"http://gaianote.github.io/tags/爬虫/"}]},{"title":"python规范目录结构","slug":"python规范目录结构","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.416Z","comments":true,"path":"2017/04/23/python规范目录结构/","link":"","permalink":"http://gaianote.github.io/2017/04/23/python规范目录结构/","excerpt":"","text":"假设项目名称为Foo 123456789101112131415Foo/|-- bin/ #存放项目的一些可执行文件| |-- foo|-- foo/ # 所有模块、包都应该放在此目录，程序的入口最好命名为main.py| |-- tests/ # 存放单元测试代码；| | |-- __init__.py| | |-- test_main.py| |-- __init__.py| |-- main.py|-- docs/ # 用于存放文档| |-- conf.py| |-- abc.rst|-- setup.py # 来管理代码的打包、安装、部署问题|-- requirements.txt # 存放软件依赖的外部Python包列表|-- README # 项目说明文件 python基础6–目录结构","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"VPS与虚拟主机","slug":"VPS与虚拟主机","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.250Z","comments":true,"path":"2017/04/23/VPS与虚拟主机/","link":"","permalink":"http://gaianote.github.io/2017/04/23/VPS与虚拟主机/","excerpt":"","text":"独立服务器： 顾名思义，就是一个躺在机房的实实在在的物理服务器 VPS： Virtual Private Server 虚拟专用服务器,一般是将一个独立服务器通过虚拟化技术虚拟成多个虚拟专用服务器 云服务器 ECS： 云服务器是一个计算，网络，存储的组合。简单点说就是通过多个CPU，内存，硬盘组成的计算池和存储池和网络的组合 虚拟主机 Vhost 虚拟主机是通过，物理服务器，VPS或者云服务器安装例如CPanel，Plesk等面板搭建的","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"selenium应用指南","slug":"selenium应用指南","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-22T14:28:36.341Z","comments":true,"path":"2017/04/23/selenium应用指南/","link":"","permalink":"http://gaianote.github.io/2017/04/23/selenium应用指南/","excerpt":"","text":"安装selenium1.安装selenium,以管理员身份运行cmd,输入以下命名 1pip install selenium 2.下载chromedriver(),放到python.exe同级目录中 selenium设置请求头selenium设置phantomjs请求头：1234567891011from selenium import webdriverfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesdcap = dict(DesiredCapabilities.PHANTOMJS)dcap[\"phantomjs.page.settings.userAgent\"] = (\"Mozilla/5.0 (Linux; Android 5.1.1; Nexus 6 Build/LYZ28E) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.23 Mobile Safari/537.36\")driver = webdriver.PhantomJS(desired_capabilities=dcap)driver.get(\"https://httpbin.org/get?show_env=1\")driver.get_screenshot_as_file('01.png')driver.quit() phantomJS详细配置问题隐式等待不一定靠谱，所以尽量使用python自身函接口 12345678910111213141516from selenium import webdriver# 引入配置对象DesiredCapabilitiesfrom selenium.webdriver.common.desired_capabilities import DesiredCapabilitiesdcap = dict(DesiredCapabilities.PHANTOMJS)#从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器dcap[\"phantomjs.page.settings.userAgent\"] = (random.choice(USER_AGENTS))# 不载入图片，爬页面速度会快很多dcap[\"phantomjs.page.settings.loadImages\"] = False# 设置代理service_args = ['--proxy=127.0.0.1:9999','--proxy-type=socks5']#打开带配置信息的phantomJS浏览器driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap,service_args=service_args)# 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项driver.set_page_load_timeout(10)# 设置10秒脚本超时时间driver.set_script_timeout(10) phantomJS与并发 IO密集型的程序，多线程/协程比较合适。对于Chrome程序能正常运行，而phantomJS有时有问题 phantomJS本身在多线程方面还有很多bug，建议使用多进程 12345from multiprocessing import Poolpool = Pool(8)data_list = pool.map(get, url_list)pool.close()pool.join() selenium设置chrome请求头：1234567891011from selenium import webdriveroptions = webdriver.ChromeOptions()options.add_argument('lang=zh_CN.UTF-8')# 设置headeroptions.add_argument('user-agent=Mozilla/5.0 (iPod; U; CPU iPhone OS 2_1 like Mac OS X; ja-jp) AppleWebKit/525.18.1 (KHTML, like Gecko) Version/3.1.1 Mobile/5F137 Safari/525.20')# 设置代理options.add_argument('--proxy-server=127.0.0.1:9999')browser = webdriver.Chrome(chrome_options=options)url = \"https://httpbin.org/get?show_env=1\"browser.get(url)browser.quit() 携带cookie123456789from selenium import webdriverbrowser = webdriver.Chrome()url = \"https://www.baidu.com/\"browser.get(url)browser.delete_all_cookies()browser.add_cookie(&#123;'name':'ABC','value':'DEF'&#125;)input(\"查看效果\")browser.quit() 超时设置123456from selenium import webdriverd= webdriver.PhantomJS()#这两种设置都进行才有效d.set_page_load_timeout(10)d.set_script_timeout(10) 参考文档selinium设置请求头盘点selenium phantomJS使用的坑selenium设置Chrome","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"},{"name":"selenium","slug":"selenium","permalink":"http://gaianote.github.io/tags/selenium/"}]},{"title":"Python使用requirement.txt实现自动打包部署","slug":"Python使用requirement.txt实现自动打包部署","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.235Z","comments":true,"path":"2017/04/23/Python使用requirement.txt实现自动打包部署/","link":"","permalink":"http://gaianote.github.io/2017/04/23/Python使用requirement.txt实现自动打包部署/","excerpt":"","text":"不要在本地打包依赖python一些模块是下载源码然后本机编译的。如果本机打包模块发布在别的机器上可能会出现兼容性问题。所以，统一使用pip进行模块安装打包。 使用pip进行依赖部署在开发环境中，统一运行以下命令安装依赖 1sudo pip install xx 在开发环境中，运行以下命令导出依赖 1pip freeze &gt; requirement.txt 在生产环境中，执行以下命令安装依赖 1pip install -r requirement.txt","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"python实现windows系统下自动拨号","slug":"python实现windows系统下自动拨号","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.408Z","comments":true,"path":"2017/04/23/python实现windows系统下自动拨号/","link":"","permalink":"http://gaianote.github.io/2017/04/23/python实现windows系统下自动拨号/","excerpt":"","text":"1234567891011121314151617class Adsl(object): def __init__(self): # 分别填写adsl名称，用户名与密码，dsl名称一般为宽带连接 self.name = \"宽带连接\" self.username = 'adsl_uname' self.password = 'adsl_upwd' def connect(self): cmd_str = \"rasdial %s %s %s\" % (self.name, self.username, self.password) os.system(cmd_str) time.sleep(5) def disconnect(self): cmd_str = \"rasdial %s /disconnect\" % self.name os.system(cmd_str) time.sleep(5) def reconnect(self): self.disconnect() self.connect()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"sqlite速查手册","slug":"sqlite速查手册","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.439Z","comments":true,"path":"2017/04/23/sqlite速查手册/","link":"","permalink":"http://gaianote.github.io/2017/04/23/sqlite速查手册/","excerpt":"","text":"1234567891011121314151617181920# 返回数据表的最大行数sql = 'SELECT count(*) FROM table_name;'# 选择某列最大或最小值,计算平均值与和sql = 'SELECT max(coloumn) FROM table_name;'sql = 'SELECT min(coloumn) FROM table_name;'sql = 'SELECT avg(coloumn) FROM table_name;'sql = 'SELECT sum(coloumn) FROM table_name;'############ 操作数据库 ############### 得到所有的表名，使用fetchallsql = 'select * from sqlite_master'############ 操作数据表 ############### 获得所有列名sql = \"PRAGMA table_info(table_name)\"# 改变表名sql = 'ALTER TABLE old_table_name RENAME new_table_name 新表名'# 增加一列sql = 'ALTER TABLE 表名 ADD COLUMN 列名 数据类型'","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"将Python代码打包放到PyPI上","slug":"将Python代码打包放到PyPI上","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.510Z","comments":true,"path":"2017/04/23/将Python代码打包放到PyPI上/","link":"","permalink":"http://gaianote.github.io/2017/04/23/将Python代码打包放到PyPI上/","excerpt":"","text":"什么是PyPIPyPI(Python Package Index)是python官方的第三方库的仓库。所有人都可以下载第三方库或上传自己开发的库到PyPI。PyPI推荐使用pip包管理器来下载第三方库 包的文件结构123456789101112131415foo|-- bin/ #存放项目的一些可执行文件| |-- foo|-- foo/ # 所有模块、包都应该放在此目录，程序的入口最好命名为main.py| |-- tests/ # 存放单元测试代码；| | |-- __init__.py| | |-- test_main.py| |-- __init__.py| |-- main.py|-- docs/ # 用于存放文档| |-- conf.py| |-- abc.rst|-- setup.py # 来管理代码的打包、安装、部署问题|-- requirements.txt # 存放软件依赖的外部Python包列表|-- README.rst # 项目说明文件 setup文件1234567891011121314151617181920212223242526272829303132333435363738import codecsimport osimport systry: from setuptools import setupexcept: from distutils.core import setupdef read(fname): return codecs.open(os.path.join(os.path.dirname(__file__), fname)).read()NAME = \"project_name\"PACKAGES = [\"somefunctions\",]DESCRIPTION = \"package description.\"LONG_DESCRIPTION = read(\"README.rst\")KEYWORDS = \"test python package\"AUTHOR = \"your_name\"AUTHOR_EMAIL = \"youremail@email.com\"URL = \"http://your_blog/\"VERSION = \"1.0.1\"LICENSE = \"MIT\"CLASSFIERS = ['License :: OSI Approved :: MIT License','Programming Language :: Python','Intended Audience :: Developers','Operating System :: OS Independent']setup( name = NAME, version = VERSION, description = DESCRIPTION, long_description =LONG_DESCRIPTION, classifiers = CLASSFIERS, keywords = KEYWORDS, author = AUTHOR, author_email = AUTHOR_EMAIL, url = URL, license = LICENSE, packages = PACKAGES, include_package_data=True, zip_safe=True,) 打包上传使用check命令查看是否存在语法问题，使用sdist进行打包。 12python setup.py checkpython setup.py sdist 发布前，需要到pypi官网注册一个账号，并在用户目录新建文件 ~/.pypirc ，并键入以下内容 123456[distutils]index-servers = pypi[pypi]repository: https://pypi.python.org/pypiusername: yournamepassword: yourpwd 执行以下内容进行打包上传，服务器返回Server response (200): OK表示上传成功 1python setup.py sdist upload 发布成功后就可以使用pip install安装你自己的python包了！ 参考资料Invalid or non-existent authentication information","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"python协程与异步IO","slug":"python协程与异步IO","date":"2017-04-23T14:07:42.000Z","updated":"2017-05-16T02:52:15.401Z","comments":true,"path":"2017/04/23/python协程与异步IO/","link":"","permalink":"http://gaianote.github.io/2017/04/23/python协程与异步IO/","excerpt":"","text":"协程协程的用途在于IO，遇到IO就挂起，并发执行另一个任务，比如http请求，可以实现同时请求若干个网站的目的但是很多经典库比如requests并不支持协程 生成器与协程 PEP-0492 通过使用 async 关键字显式的对生成器和协程做了区分。 实际上，使用async显示声明协程（函数），并在函数内使用wait代替yield，一个协程变诞生了 生成器 yield的功能类似于return，但是不同之处在于它返回的是生成器 生成器是通过一个或多个yield表达式构成的函数，每一个生成器都是一个迭代器(for循环或while循环) 如果一个函数包含yield关键字，这个函数就会变为一个生成器。 生成器并不会一次返回所有结果，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。 由于生成器也是一个迭代器，那么它就应该支持next方法来获取下一个值 1234567891011121314151617181920212223242526def func(): n = 0 print(n) while 1: print(n,'a') n = yield n #可以通过send函数向n赋值 print(n,'b')f = func()print(f)# 生成一个&lt;generator object func at 0x030489F0&gt;f.send(None) # 启动生成器# f.send(None)遇到yield 中断00 af.send(1)# n被赋值为1，循环遇到yield中断1 b1 af.send(2)# f.send(2)，n被赋值为2，循环遇到yield中断2 b2 a 生产者-消费者模型传统的生产者-消费者模型是一个线程写消息，一个线程取消息，通过锁机制控制队列和等待，但一不小心就可能死锁。如果改用协程，生产者生产消息后，直接通过yield跳转到消费者开始执行，待消费者执行完毕后，切换回生产者继续生产，效率极高 123456789101112131415161718192021def consumer(): r = '' while True: n = yield r if not n: return print('[CONSUMER] Consuming %s...' % n) r = '200 OK'def produce(c): c.send(None) n = 0 while n &lt; 5: n = n + 1 print('[PRODUCER] Producing %s...' % n) r = c.send(n) print('[PRODUCER] Consumer return: %s' % r) c.close()c = consumer()produce(c) 执行过程分析 c = consumer(),生成generator c.send(None)其实等价于next(c),第一次执行时其实只执行到n = yield r就停止了，然后把r的值返回给调用者。用于启动生成器 yield r是一个表达式，通过send(msg)被赋值，而send(msg)是有返回值的，返回值为：下一个yield r表达式的参数，即为r。 produce一旦生产了东西，通过c.send(n)切换到consumer执行。consumer通过yield拿到消息，处理，又通过yield把结果传回。也就是说，c.send(1) 不但会给 c 传送一个数据，它还会等着下次 yield 从 c 中返回一个数据，它是有返回值的，一去一回才算完，拿到了返回的数据(200 OK)才继续下面执行。 整个流程无锁，由一个线程执行，produce和consumer协作完成任务，所以称为“协程”，而非线程的抢占式多任务。 asyncioasyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持 12345678910111213import timeimport asyncio@asyncio.coroutinedef hello(): print('Hello world!') yield from asyncio.sleep(1) print('Hello end!')tasks = [hello(), hello()]loop = asyncio.get_event_loop()loop.run_until_complete(asyncio.wait(tasks))loop.close() 两个hello()是由同一个线程并发执行的,返回结果为 12345678# 单线程依次执行print('Hello world!')Hello world!Hello world!# 执行异步操作asyncio.sleep(1)暂停1s# 单线程依次执行print('Hello end!')Hello end!Hello end! async/awaitasync/await是自python 3.5开始后asyncio实现的新语法 把@asyncio.coroutine替换为async； 把yield from替换为await。 1234async def hello(): print(\"Hello start!\") r = await asyncio.sleep(1) print(\"Hello end!\") aiohttpasyncio可以实现单线程并发IO操作。如果仅用在客户端，发挥的威力不大。 如果把asyncio用在服务器端，例如Web服务器，由于HTTP连接就是IO操作，因此可以用单线程+coroutine实现多用户的高并发支持。 asyncio实现了TCP、UDP、SSL等协议，aiohttp则是基于asyncio实现的HTTP框架。 1pip install aiohttp 1234567891011121314151617181920212223import asynciofrom aiohttp import webasync def index(request): await asyncio.sleep(0.5) # 模拟io阻塞 return web.Response(body=b'&lt;h1&gt;Index&lt;/h1&gt;',content_type='text/html')async def hello(request): await asyncio.sleep(0.5) text = '&lt;h1&gt;hello, %s!&lt;/h1&gt;' % request.match_info['name'] return web.Response(body=text.encode('utf-8'),content_type='text/html')async def init(loop): app = web.Application(loop=loop) app.router.add_route('GET', '/', index) app.router.add_route('GET', '/hello/&#123;name&#125;', hello) srv = await loop.create_server(app.make_handler(), '127.0.0.1', 8000) print('Server started at http://127.0.0.1:8000...') return srvloop = asyncio.get_event_loop()loop.run_until_complete(init(loop))loop.run_forever() python并发之协程python:利用asyncio进行快速抓取玩转 Python 3.5 的 await/asyncPython 3.5 协程究竟是个啥","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"利用Python和win32编程范例","slug":"利用Python和win32编程范例","date":"2017-04-23T14:04:01.000Z","updated":"2017-05-16T02:52:15.477Z","comments":true,"path":"2017/04/23/利用Python和win32编程范例/","link":"","permalink":"http://gaianote.github.io/2017/04/23/利用Python和win32编程范例/","excerpt":"","text":"学习pywin32之前，我们先要了解一些概念 句柄是一个32位整数，在windows中标记对象用，类似一个dict中的key 消息是windows应用的重要部分，比如给一个按钮发送BN_CLICKED,按钮就会知道自己被点击了 为了方面查找目标窗口的句柄，可以下载一个微软自家的Spy++ 使用pip安装pywin32 1pip install pypiwin32 快速开始 123import win32apiimport win32conwin32api.MessageBox(win32con.NULL, 'Python 你好！', '你好', win32con.MB_OK) 运行以上程序你会得到一个python版本的弹窗，是不是非常简单呢 参考文档按需定制一个按键精灵Python在Windows下系统编程初步","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://gaianote.github.io/tags/python/"}]},{"title":"如何区分真实点击与js的click","slug":"如何区分真实点击与js的click","date":"2017-04-23T14:02:19.000Z","updated":"2017-05-16T02:52:15.506Z","comments":true,"path":"2017/04/23/如何区分真实点击与js的click/","link":"","permalink":"http://gaianote.github.io/2017/04/23/如何区分真实点击与js的click/","excerpt":"","text":"区分真实与虚拟点击使用event.isTrusted以及e.clientX, e.pageX可以区分真实点击与js虚拟点击 1234elem = document.querySelector('#elem_id')elem.addEventListener('click',function(e)&#123; console.log(e.isTrusted,e.clientX,e.clientY,e.pageX,e.pageY)&#125;) 鼠标真实点击，控制台输出了 true 60 60通过js控制的elem.click()，控制台输出false 0 0 使用javascript尝试破解对于坐标，可以通过自定义事件解决，但是坐标范围比较麻烦而且对于浏览器底层的event.isTrusted无解所以总体来说，js无法解决此问题 12345678//event = new MouseEvent(typeArg, mouseEventInit);var event = new MouseEvent('click', &#123; 'screenX': 10, 'screenY': 10, 'clientX': 10, 'clientY': 10&#125;);elem.dispatchEvent(event) 输出结果为 false 10 10 10 10 使用selinium模拟真实点击通过自动化测试软件selinium，注入检测用js代码并执行点击操作 1browser.find_element_by_id(\"elem_id\").click() 查看控制台输出结果为：true 633 358 633 458 网页中，鼠标点击与javascript的click事件怎么区分javascript自定义事件(event)MouseEvent()","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://gaianote.github.io/tags/javascript/"}]},{"title":"if __name__ == '__main__'浅析","slug":"if __name__ == '__main__'浅析","date":"2017-04-23T13:19:05.000Z","updated":"2017-05-16T02:52:15.271Z","comments":true,"path":"2017/04/23/if __name__ == '__main__'浅析/","link":"","permalink":"http://gaianote.github.io/2017/04/23/if __name__ == '__main__'浅析/","excerpt":"","text":"1234def main(): print \"we are in %s\"%__name__if __name__ == '__main__': main() 其中 __name__ == &#39;__main__&#39;: 的作用是：当该文件作为脚本运行时，main()函数可以运行当该文件作为模块被其他文件导入时，main()函数不会运行,避免了模块重复运行","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"nodejs路径略解与path模块","slug":"nodejs路径略解与path模块","date":"2017-04-23T13:19:05.000Z","updated":"2017-05-16T02:52:15.375Z","comments":true,"path":"2017/04/23/nodejs路径略解与path模块/","link":"","permalink":"http://gaianote.github.io/2017/04/23/nodejs路径略解与path模块/","excerpt":"","text":"绝对路径与相对路径nodejs中有三种绝对路径和两种相对路径 __dirname: 总是返回被执行的 js 所在文件夹的绝对路径 __filename: 总是返回被执行的 js 文件的绝对路径 process.cwd(): 总是返回运行 node 命令时所在的文件夹的绝对路径 ./ ../ 举个例子，我有一个模块，文件结构如下： 12345app/ -lib/ -common.js -model -task.js 在app文件夹执行cmd命令 node task.js 结果如下： 123__dirname : /Users/app/model__filename : /Users/app/model/task.jsprocess.cwd() : /Users/app 在model文件夹执行cmd命令 node task.js 结果如下： 123__dirname : /Users/app/model__filename : /Users/app/model/task.jsprocess.cwd() : /Users/app 对于 ./ 有如下结论： 在 require() 中使用是跟 __dirname 的效果相同，不会因为启动脚本的目录不一样而改变，在其他情况下跟 process.cwd() 效果相同，是相对于启动脚本所在目录的路径。 因此只有在 require() 时才使用相对路径(./, ../) 的写法，其他地方一律使用绝对路径，如下： 1234// 当前目录下path.dirname(__filename) + '/task.js';// 相邻目录下path.resolve(__dirname, '../lib/common.js'); 参考资料浅析 NodeJs 的几种文件路径","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"Tesseract-OCR识别中文与训练字库","slug":"Tesseract-OCR识别中文与训练字库","date":"2017-04-23T13:19:05.000Z","updated":"2017-05-16T02:52:15.244Z","comments":true,"path":"2017/04/23/Tesseract-OCR识别中文与训练字库/","link":"","permalink":"http://gaianote.github.io/2017/04/23/Tesseract-OCR识别中文与训练字库/","excerpt":"","text":"准备工作 下载最新版Tesseract-OCR引擎，安装时勾选 chi_sim 字库以及path 加入到系统变量 下载jTessBoxEditor，这个是用来训练字库的。 下载java虚拟机用以支持jTessBoxEditor 开始12# 生成box文件tesseract langyp.fontyp.exp0.tif langyp.fontyp.exp0 -l eng -psm 7 batch.nochop makebox 使用jTessBoxEditor进行编辑 1234567891011121314151617181920# 生成font_propertiesecho fontyp 0 0 0 0 0 &gt;font_properties# 生成训练文件tesseract langyp.fontyp.exp0.tif langyp.fontyp.exp0 -l eng -psm 7 nobatch box.train# 生成字符集文件unicharset_extractor langyp.fontyp.exp0.box# 生成shape文件shapeclustering -F font_properties -U unicharset -O langyp.unicharset langyp.fontyp.exp0.tr# 生成聚集字符特征文件mftraining -F font_properties -U unicharset -O langyp.unicharset langyp.fontyp.exp0.tr# 生成字符正常化特征文件cntraining langyp.fontyp.exp0.tr# 更名rename normproto fontyp.normprotorename inttemp fontyp.inttemprename pffmtable fontyp.pffmtablerename unicharset fontyp.unicharsetrename shapetable fontyp.shapetable# 合并训练文件combine_tessdata fontyp. 将fontyp.traineddata拷贝到tesseract安装目录的tessdata目录下。 参考链接：Tesseract-OCR识别中文与训练字库利用jTessBoxEditor工具进行Tesseract3.02.02样本训练，提高验证码识别率I dont know why the Tesseract-OCR is good","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"npm常用命令与nodejs版本更新","slug":"npm常用命令与nodejs版本更新","date":"2017-04-22T18:02:22.000Z","updated":"2017-05-16T02:52:15.393Z","comments":true,"path":"2017/04/23/npm常用命令与nodejs版本更新/","link":"","permalink":"http://gaianote.github.io/2017/04/23/npm常用命令与nodejs版本更新/","excerpt":"","text":"更新nodejsnode有一个模块叫n，是专门用来管理node.js的版本的。 12npm install -g nn stable # 升级node.js到最新稳定版 可惜不支持windows，windows直接到官网下载即可 npm 常用命令1234567891011npm -v #显示版本，检查npm 是否正确安装。npm install express #安装express模块npm install -g express #全局安装express模块npm list #列出已安装模块npm show express #显示模块详情npm update #升级当前目录下的项目的所有模块npm update express #升级当前目录下的项目的指定模块npm update -g express #升级全局安装的express模块npm uninstall express #删除指定的模块npm linknpm unlink","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://gaianote.github.io/tags/nodejs/"}]},{"title":"使用hexo搭建博客并托管在github","slug":"使用hexo搭建个人博客","date":"2017-04-22T16:03:44.000Z","updated":"2017-05-16T02:52:15.466Z","comments":true,"path":"2017/04/23/使用hexo搭建个人博客/","link":"","permalink":"http://gaianote.github.io/2017/04/23/使用hexo搭建个人博客/","excerpt":"Hexo简介Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上。 使用Hexo之前，你首先需要做好准备工作:一个github账号，安装好nodejs，安装好git，当你完成上述内容后，就可以开始安装hexo了。","text":"Hexo简介Hexo 是一个简单地、轻量地、基于Node的一个静态博客框架，可以方便的生成静态网页托管在github和Heroku上。 使用Hexo之前，你首先需要做好准备工作:一个github账号，安装好nodejs，安装好git，当你完成上述内容后，就可以开始安装hexo了。 安装hexo打开cmd，依次执行以下命令 1234npm install hexo-cli -ghexo init blogcd blognpm install 基本使用新建文章 1hexo new 文章标题 启动服务器 1hexo server 执行hexo server后,可以在 http://localhost:4000/ 查看hexo创建好的博客 发布到github 发布到服务器前，需要通过hexo generate命令对所有的文章做静态化处理，生成html，css，js等文件 推送到github需要安装hexo-deployer，并且配置好_config.yml中的Deployment项，然后使用hexo deploy推送到github 1npm install hexo-deployer-git -S 12hexo generatehexo deploy 常用命令总结 1234hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy Hexo的配置文件结构12345678910111213gaianote.github.io||-public # 存放hexo生成的html文件|-dcaffolds # 模板文件夹，新建文章时，Hexo 会根据 scaffold 来建立文件| |-draft.md| |-page.md| |-post.md # 默认模板post|-source # 资源文件夹是存放用户资源的地方，Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去| |-_post # 文件箱，新建的文章存放在这里,除 _posts 文件夹之外，开头命名为 _ (下划线)的文件/ 文件夹和隐藏的文件将会被忽略|-themes # 存放主题文件，Hexo 会根据主题来生成静态页面| |-landscape ：默认的主题文件夹|-_config.yml # 全局配置文件，每次更改要重启服务| 配置文件 _config.yml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# Site 站点配置title: 李云鹏的个人博客 # 网站标题subtitle:description:author: 李云鹏language: zh-CNtimezone:# URL 链接配置url: http://gaianote.github.ioroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directory 目录配置source_dir: source # 资源文件夹，这个文件夹用来存放内容public_dir: public # 公共文件夹，这个文件夹用于存放生成的站点文件tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化文件夹skip_render: # 跳过指定文件的渲染，您可使用 glob 来配置路径# Writing 写作配置new_post_name: :title.md # 新文章的文件名称default_layout: # 默认布局titlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0 # 把文件名称转换为 1 小写或 2 大写render_drafts: false # 显示草稿post_asset_folder: false # 是否启动资源文件夹relative_link: false # 把链接改为与根目录的相对位址future: truehighlight: # 代码块的设置 enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tag # 分类 &amp; 标签default_category: uncategorized # 默认分类category_map: # 分类别名tag_map: # 标签别名# Date / Time format 时间和日期date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination 分页per_page: 10 # 每页显示的文章量 (0 = 关闭分页功能)pagination_dir: page # 分页目录# Extensions 扩展theme: hexo-theme-yilia # 当前主题名称# Deployment # 部署到githubdeploy: type: git repo: https://github.com/gaianote/gaianote.github.io.git branch: master 主题配置123456789101112gaianote.github.io||-themes # 存放主题文件，Hexo 会根据主题来生成静态页面| |-landscape # 默认的主题文件夹| |-hexo-theme-yilia # 笔者使用的主题| |-languages| |-layout| |-source| |-source-src| |-_config.yml # 主题的全局配置| |-README.md # 主题的使用说明| 在使用主题过程中，我们结合 _config.yml和README.md 对主题进行设置即可 头像与favoicon放在public文件夹内即可生效 文章与草稿属性文章可以拥有如下属性,在文章的开头使用 ===== 与正文分隔 12345678910===========layout Layout ：post或pagetitle 文章的标题date 创建日期 ：文件的创建日期updated 修改日期 ：文件的修改日期comments 是否开启评论 ：true|falsetags 标签categories 分类permalink url中的名字 : 文件名=========== 分类和标签 1234567===========categories:- 日记tags:- Hexo- node.js=========== 草稿当你撰写好一篇文章，并未打算发布时，需要使用草稿功能 新建草稿 1hexo new draft \"new draft\" 新建草稿会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。 预览草稿 1hexo server --drafts 发布草稿 1hexo publish [layout] &lt;filename&gt; 保存 Hexo 博客源码到 GitHub因为 master 分支只保存了public 文件夹中的静态文件，所以需要创建一个分支来保存你的博客的源代码 使用git管理source分支 在github上新建一个分支source，并将source设置为默认分支，通过source分支使用git管理源文件 配置好 .gitnore 文件，添加规则 public，因为public使用hexo deploy管理，无需重复添加 将远程仓库克隆到本地，然后连接远程仓库 12git clone https://github.com/gaianote/gaianote.github.iogit remote add origin https://github.com/gaianote/gaianote.github.io 以后每次使用时，直接键入以下命令即可 123git add .git commit -m \"update\"git push origin source 使用 hexo deploy 管理master分支 使用 hexo deploy 管理master分支，直接将静态文件发布到master分支上(无需使用git切换到master分支) 1hexo deploy 实现流程自动化hexo写博客非常享受，但是有可以改进的地方，比如每次新建文章时，都需要在post文件中查找新建立的文档，并且每次写完文章需要使用hexo和git备份两次，比较繁琐，我们可以使用shelljs实现自动化备份 通过查阅Hexo文档 ，找到了Hexo的主要事件，见下表： 事件名 事件发生时间 deployBefore 在部署完成前发布 deployAfter 在部署成功后发布 exit 在 Hexo 结束前发布 generateBefore 在静态文件生成前发布 generateAfter 在静态文件生成后发布 new 在文章文件建立后发布 于是我们就可以通过监听Hexo的 deployAfter 事件，待上传完成之后自动运行Git备份命令，从而达到自动备份的目的。 通过监听Hexo 的 new 事件，新建文章同时使用编辑器打开文档 首先，我们需要安装模块shelljs 1npm install --save shelljs 待到模块安装完成，在博客根目录的 scripts 文件夹下新建一个js文件，文件名随意取；如果没有 scripts 目录，请新建一个。 然后在脚本内键入以下内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950require('shelljs/global');var path = require('path');/* hexo deploy 时自动执行git push */try &#123; hexo.on('deployAfter', function() &#123;//当deploy完成后执行备份 run(); &#125;);&#125; catch (e) &#123; console.log(\"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：\" + e.toString());&#125;function run() &#123; if (!which('git')) &#123; echo('Sorry, this script requires git'); exit(1); &#125; else &#123; echo(\"======================Auto Backup Begin===========================\"); cd(process.cwd()); if (exec('git add --all').code !== 0) &#123; echo('Error: Git add failed'); exit(1); &#125; if (exec('git commit -m \"update\"').code !== 0) &#123; echo('Error: Git commit failed'); exit(1); &#125; if (exec('git push origin source').code !== 0) &#123; echo('Error: Git push failed'); exit(1); &#125; echo(\"==================Auto Backup Complete============================\") &#125;&#125;/* 新建文章自动打开编辑器 */try &#123; hexo.on('new', function(data) &#123; exec(data.path) &#125;);&#125; catch (e) &#123; console.log(\"产生了一个错误&lt;(￣3￣)&gt; !，错误详情为：\" + e.toString());&#125; 这样，我们在使用Hexo命令时就可以自动触发git以及打开文章的操作了！ 参考资料hexo官网next官网Hexo 入门指南简洁轻便的博客平台: Hexo详解20分钟教你使用hexo搭建github博客自动备份Hexo博客源文件","categories":[],"tags":[{"name":"tool","slug":"tool","permalink":"http://gaianote.github.io/tags/tool/"}]}]}